<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>初探Amis</title>
      <link href="/2021/01/23/%E5%88%9D%E6%8E%A2Amis/"/>
      <url>/2021/01/23/%E5%88%9D%E6%8E%A2Amis/</url>
      
        <content type="html"><![CDATA[<h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>最近公司内部做了一些比较大的调整，框架层也从自研转到了Amis。</p><h3 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h3><p>Amis是百度出品的一款低代码框架，它使用 JSON 配置来生成页面，可以减少页面开发工作量，极大提升效率。</p><ul><li>What ?</li><li>Why ?</li><li>How ?<br>这几个问题可去官网看下介绍：<a href="https://baidu.gitee.io/amis/zh-CN/docs/index" target="_blank" rel="noopener">https://baidu.gitee.io/amis/zh-CN/docs/index</a></li></ul><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ol><li><p>配置与组件</p><ul><li>Amis通过JSON配置构建组件树(和多数低代码框架一致，不过Amis的Schema更简单些)</li><li>重要的是json type到React component的映射及数据传递<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;xxx&quot;,</span><br><span class="line">  ...其它属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数据域与数据链</p><ul><li>数据域就是json节点上有个特殊的<strong>data</strong>属性，在配置其他属性是可以直接从data里取得数据</li><li>可与后台协商直接通过接口板返回data数据做出更加灵活的配置</li><li>数据链的设计应该是模仿JavaScript的原型链设计，就是data的取值可以延伸到父级，直到根节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">  &quot;type&quot;: &quot;page&quot;,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;zhangsan&quot;,</span><br><span class="line">    &quot;age&quot;: 20</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;body&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;tpl&quot;,</span><br><span class="line">      &quot;tpl&quot;: &quot;my name is $&#123;name&#125;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;service&quot;,</span><br><span class="line">      &quot;data&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;lisi&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;body&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;tpl&quot;,</span><br><span class="line">        &quot;tpl&quot;: &quot;my name is $&#123;name&#125;, I&apos;m $&#123;age&#125; years old&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>模板</p><ul><li>模板中可以嵌入数据域的数据、HTML、及一些js表达式</li><li><strong>模板 + 数据域 + 数据链</strong> 可以产出非常灵活的Schema，这也是json配置满足大部分需求的基础</li></ul></li><li><p>数据映射</p><ul><li>数据映射其实基本用到的就是模板取值能力，Amis额外添加了链式取值、过滤器等一些方便的操作</li><li>除此之外，对于一些复杂的数据结构，Amis提供了<strong>&amp;</strong>用来展开对象、<strong>$</strong>用来提取数组</li></ul></li><li><p>表达式</p><ul><li>这个表达式仅限于结果为Boolean类型，主要用于一些开关的控制</li><li>如是否请求接口、是否展示，一般属性命名为xxxOn<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">  &quot;type&quot;: &quot;tpl&quot;,</span><br><span class="line">  &quot;tpl&quot;: &quot;当前作用域中变量 show 是 1 的时候才可以看得到我哦~&quot;,</span><br><span class="line">  &quot;visibleOn&quot;: &quot;this.show === 1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>联动</p><ul><li>联动指的是组件之间的行为交互及数据交换</li><li>对于行为控制一般是使用表达式</li><li>对于form的数据交互，一般使用target触发</li></ul></li><li><p>行为</p><ul><li>Amis内置了一个Action控件，可以接受各种事件</li><li>包括ajax、表单提交、弹出Dialog…<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">  &quot;type&quot;: &quot;page&quot;,</span><br><span class="line">  &quot;body&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;action&quot;,</span><br><span class="line">    &quot;label&quot;: &quot;发出一个请求&quot;,</span><br><span class="line">    &quot;actionType&quot;: &quot;ajax&quot;,</span><br><span class="line">    &quot;api&quot;: &quot;https://3xsw4ap8wah59.cfc-execute.bj.baidubce.com/api/amis-mock/mock2/form/saveForm&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>样式</p><ul><li>Amis中的样式主要还是通过className去自定义</li><li>也提供了一些方便的class集合供我们快速使用(旧)</li><li>后面辅助class精简了tailwindcss并提供了一些Css变量</li></ul></li></ol><h3 id="核心类型"><a href="#核心类型" class="headerlink" title="核心类型"></a>核心类型</h3><ol><li>SchemaNode<ul><li>每一个SchemaNode对应到React其实就是一个真实的Component</li><li>由大量SchemaNode构成的json结构其实就是一个React组件树</li></ul></li><li>API<ul><li>Amis为了更加灵活的json配置，提供API直接可以将后台的数据融合到SchemaNode的数据域(data)中</li></ul></li><li>Definitions<ul><li>类似一些框架中的Mix，定义一些公用的SchemaNode</li><li>其他地方可直接引用</li></ul></li></ol><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p><a href="https://baidu.gitee.io/amis/zh-CN/docs/components/component" target="_blank" rel="noopener">https://baidu.gitee.io/amis/zh-CN/docs/components/component</a></p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>amis 的渲染过程是将 json 转成对应的 React 组件。先通过 json 的 type 找到对应的 Component 然后，然后把其他属性作为 props 传递过去完成渲染，具体：<br>首先是向Amis注册React组件(@Renderer || @FormItem)，注册好组件池之后，Amis便能从json的type信息及相关path定义找到对应的组件并渲染。</p><ol><li><p>组件注册</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Renderer(&#123;</span><br><span class="line">  test: <span class="regexp">/(^|\/)form$/</span></span><br><span class="line">  <span class="comment">// ... 其他信息隐藏了</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">FormRenderer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... 其他信息隐藏了</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      title,</span><br><span class="line">      controls,</span><br><span class="line">      render <span class="comment">// 用来渲染孩子节点，如果当前是叶子节点则可以忽略。</span></span><br><span class="line">    &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form className=<span class="string">"form"</span>&gt;</span><br><span class="line">        &#123;controls.map(<span class="function">(<span class="params">control, index</span>) =&gt;</span> (</span><br><span class="line">          &lt;div className=<span class="string">"form-item"</span> key=&#123;index&#125;&gt;</span><br><span class="line">            &#123;render(<span class="string">`<span class="subst">$&#123;index&#125;</span>/control`</span>, control)&#125;</span><br><span class="line">          &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Schema</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"page"</span>,</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"页面标题"</span>,</span><br><span class="line">  <span class="attr">"subTitle"</span>: <span class="string">"副标题"</span>,</span><br><span class="line">  <span class="attr">"body"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"form"</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"用户登录"</span>,</span><br><span class="line">    <span class="attr">"controls"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"username"</span>,</span><br><span class="line">        <span class="attr">"label"</span>: <span class="string">"用户名"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>真实渲染</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;Page title=<span class="string">"页面标题"</span> subTitle=<span class="string">"副标题"</span>&gt;</span><br><span class="line">  &lt;Form</span><br><span class="line">    title=<span class="string">"用户登录"</span></span><br><span class="line">    controls=&#123;[</span><br><span class="line">      &#123;</span><br><span class="line">        type: <span class="string">'text'</span>,</span><br><span class="line">        name: <span class="string">'username'</span>,</span><br><span class="line">        label: <span class="string">'用户名'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;<span class="regexp">/Page&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ol><li><p>自定义组件<br>Amis提供了两种方式来使用，SDK + React，SDK的方式就忽略了，SDK方式主要是暴露给用户做一些简单的扩展。自己用的时候基本表都是集成React来用。为了满足更加复杂的需求，Amis除了内置的一些组件外，还支持我们自定义组件，然后注册到Amis组件池中供我们在json中配置使用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;FormItem&#125; <span class="keyword">from</span> <span class="string">'amis'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> cx <span class="keyword">from</span> <span class="string">'classnames'</span>;</span><br><span class="line"></span><br><span class="line">@FormItem(&#123;</span><br><span class="line">  type: <span class="string">'custom-checkbox'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCheckbox</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  validate() &#123;</span><br><span class="line">    <span class="comment">// 通过 this.props.value 可以知道当前值。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isValid ? <span class="string">''</span> : <span class="string">'不合法，说明不合法原因。'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ... 其他省略了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>扩展Amis内置组件</p></li></ol><h3 id="端上定制"><a href="#端上定制" class="headerlink" title="端上定制"></a>端上定制</h3><ol><li>通过特定结点属性(mobile)</li><li>通过class特定前缀(m:)</li></ol><h3 id="多语言"><a href="#多语言" class="headerlink" title="多语言"></a>多语言</h3><ol><li>内置中文 + 英文</li><li>扩展，参照英文扩展</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>简单：Schema配置足够简单。</li><li>灵活：数据域、数据链、模板提供灵活的配置</li><li>扩展能力强：自定义组件，能满足各种需求【但也和low code背道而驰】</li></ol><p>在实际的开发过程中，也的确遇到了很多问题：</p><ol><li>社区用户少</li><li>文档不完善</li><li>框架本身还不够成熟（开源、面向客户的产品）</li><li>以及面对复杂的业务场景，内置的一些组件组合无法满足需求，需要做大量的Hack或适配开发</li></ol><p>好在Amis的设计不是特别复杂，源码阅读基本无障碍，所以也很快能基于源码的设计给出一些解决方案，不至于一些业务能力无法实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Amis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录下正则表达式实战</title>
      <link href="/2020/08/19/%E8%AE%B0%E5%BD%95%E4%B8%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E6%88%98/"/>
      <url>/2020/08/19/%E8%AE%B0%E5%BD%95%E4%B8%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>今天看同事写多货币的格式解析时使用了switch语句，看着挺有意思的。于是下班后想看看自己怎么实现，因为一开始就想到了正则表达式去解析格式，尝试写了下，突然发现自己的正则水平和几个月前已经完全不一样了⬆️，什么取非、捕获、变量啥的，简直信手拈来~</p><p><img alt="代码" data-src="/images/2020-08-19.png"></p><h3 id="代码传送门"><a href="#代码传送门" class="headerlink" title="代码传送门"></a>代码传送门</h3><p><a href="https://github.com/iWuzhi/web-utils/blob/master/CurrencyParser" target="_blank" rel="noopener">https://github.com/iWuzhi/web-utils/blob/master/CurrencyParser</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>When to Use Derived State ?</title>
      <link href="/2020/08/18/When-to-Use-Derived-State/"/>
      <url>/2020/08/18/When-to-Use-Derived-State/</url>
      
        <content type="html"><![CDATA[<h3 id="When-to-Use-Derived-State？"><a href="#When-to-Use-Derived-State？" class="headerlink" title="When to Use Derived State？"></a>When to Use Derived State？</h3><ol><li>props某个值变化必定会引起组件state的某个值变化</li><li>其他情况该state的值均由该组件内部控制</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Picker弹窗位于表单之下问题查找记录</title>
      <link href="/2020/08/17/Picker%E5%BC%B9%E7%AA%97%E4%BD%8D%E4%BA%8E%E8%A1%A8%E5%8D%95%E4%B9%8B%E4%B8%8B%E9%97%AE%E9%A2%98%E6%9F%A5%E6%89%BE%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/08/17/Picker%E5%BC%B9%E7%AA%97%E4%BD%8D%E4%BA%8E%E8%A1%A8%E5%8D%95%E4%B9%8B%E4%B8%8B%E9%97%AE%E9%A2%98%E6%9F%A5%E6%89%BE%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>今天遇到一个问题，picker列表第一次弹出的时候出现在表单之下。在分析获得原因后，计算了一下花费的时间，从早上11:00开始正式投入，到下午4:00多，大概花费了4个小时多，基本就多半天的时间没了，因为分析后感觉原因很简单，但过程花费了这么多时间，于是分析了下自己在这个过程中到底将时间花在哪里了及原因。</p><h3 id="Step-1-现象分析【30min-】"><a href="#Step-1-现象分析【30min-】" class="headerlink" title="Step 1: 现象分析【30min-】"></a>Step 1: 现象分析【30min-】</h3><p>稍加分析便知道是因为z-index值初次设置不对，但z-index值是从何时哪里设置的，查找起来比较麻烦(项目比较庞大且是老项目和React糅合，业务也很复杂，看起来真的很费劲)。</p><h3 id="Step-2-顺藤摸瓜【1h30min-】"><a href="#Step-2-顺藤摸瓜【1h30min-】" class="headerlink" title="Step 2: 顺藤摸瓜【1h30min+】"></a>Step 2: 顺藤摸瓜【1h30min+】</h3><p>从React项目的form的picker点击事件经中间衔接层到到老项目的$.dialog，其中对jQuery-ui不了解，熟悉了一下widget的生命周期，这个也花了不少时间，这其中更是由于业务关系，层层嵌套、继承，真的是****</p><h3 id="Step-3-弹窗起源-30min"><a href="#Step-3-弹窗起源-30min" class="headerlink" title="Step 3: 弹窗起源[30min-]"></a>Step 3: 弹窗起源[30min-]</h3><p>要想知道z-index的值是如何被赋予的，就必须知道整个弹窗是如何被创建然后挂载到DOM上的，其实找到dialog就好办多了，直接去看jquery-ui的源码就可以，<a href="https://github.com/jquery/jquery-ui/blob/master/ui/widgets/dialog.js" target="_blank" rel="noopener">dialog源码#_moveToTop</a></p><h3 id="Step-4-解决问题？"><a href="#Step-4-解决问题？" class="headerlink" title="Step 4: 解决问题？"></a>Step 4: 解决问题？</h3><p>现在已经基本知道问题了，锁定在可视元素.ui-front类即可，第一次为什么没有设置z-index值，肯定是因为找不到可视的.ui-front类。可还有一个问题，线上环境第一次弹出却是正确的</p><h3 id="Step-5-线上为什么第一次弹出时就有了可视的-ui-front类？？？【1h30min-】"><a href="#Step-5-线上为什么第一次弹出时就有了可视的-ui-front类？？？【1h30min-】" class="headerlink" title="Step 5: 线上为什么第一次弹出时就有了可视的.ui-front类？？？【1h30min+】"></a>Step 5: 线上为什么第一次弹出时就有了可视的.ui-front类？？？【1h30min+】</h3><p>说起这个可真是**，<a href="https://github.com/jquery/jquery-ui/blob/master/ui/widgets/dialog.js" target="_blank" rel="noopener">dialog源码#_createOverlay</a>，如果options.modal是true的话，就动态的造一个，****，_createOverlay到现在还没理解用来干嘛的，也没issue，**</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Step1-Step3可以说是正常消费，Step5完全是出乎意料，就不完全不懂作者的意图。总的来说，这其中消费了大量的时间，其实都是源于对jquery-ui的不熟，不然Step2、Step5基本可以省下来。算下来，除了Step5的时间花的不值得，其他时间消费还在情理之中。</p><h3 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h3><p>凡是消费<strong>30min</strong>以上的问题查找，一定要重新提问(确定自己需要解决什么问题，现在正在解决什么问题)，确保查找方向不会走偏，要不真的就是在浪费时间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工作日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS布局之Grid</title>
      <link href="/2020/05/03/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/"/>
      <url>/2020/05/03/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://css-tricks.com/snippets/css/complete-guide-grid/" target="_blank" rel="noopener">https://css-tricks.com/snippets/css/complete-guide-grid/</a></p></blockquote><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><ol><li>Grid Contianer</li><li>Grid Item</li><li>Grid Line</li><li>Grid Cell</li><li>Grid Track</li><li>Grid Area<ul><li>横跨行或列的多个Cell集合</li></ul></li></ol><h3 id="Grid-Container的属性"><a href="#Grid-Container的属性" class="headerlink" title="Grid Container的属性"></a>Grid Container的属性</h3><ol><li>display: grid | inline-grid;</li><li>grid-template-columns:  … |   …;<ul><li>单位可以是长度、百分比、fr（剩余空间占比）</li><li>line-name可以指定一个更可读的名称，用来代替指个具体的line(默认是: 1~n, -n~-1)，可以在item里使用，同时可以指定多个line-name</li><li>repeat()函数可更简洁方便的定义重复部分</li><li>多个line具有相同的line-name时，可以指定count来获取具体某一个line</li></ul></li><li>grid-template-rows</li><li>grid-template-areas<ul><li>定义grid-area</li><li>.表示一个空格子</li><li>相同的name定义会组成一个area区域，可供Item直接使用</li></ul></li><li>grid-template: none | &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt;;</li><li>column-gap: &lt;line-size&gt;;</li><li>row-gap: &lt;line-size&gt;;</li><li>gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;</li><li>justify-items: start | end | center | stretch;<ul><li>针对Cell对齐、Row</li></ul></li><li>align-items: start | end | center | stretch;<ul><li>针对Cell对齐、Column</li></ul></li><li>place-items: &lt;align-items&gt; / &lt;justify-items&gt;</li><li>justify-content: start | end | center | stretch | space-around | space-between | space-evenly;<ul><li>针对Container、Row</li></ul></li><li>align-content: start | end | center | stretch | space-around | space-between | space-evenly;<ul><li>针对Container、Column</li></ul></li><li>place-content: &lt;align-content&gt; / &lt;justify-content&gt;</li><li>grid-auto-columns: &lt;track-size&gt; …;<ul><li>定义容器之外的默认空间</li></ul></li><li>grid-auto-rows: &lt;track-size&gt; …;</li><li>grid</li></ol><hr><h3 id="Grid-Item的属性"><a href="#Grid-Item的属性" class="headerlink" title="Grid Item的属性"></a>Grid Item的属性</h3><ol><li>grid-column-start: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto;</li><li>grid-column-end: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto;</li><li>grid-row-start: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto;</li><li>grid-row-end: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto;<ul><li>可以使用z-index控制展示顺序</li></ul></li><li>grid-column: &lt;start-line&gt; / &lt;end-line&gt; | &lt;start-line&gt; / span &lt;value&gt;;</li><li>grid-row: &lt;start-line&gt; / &lt;end-line&gt; | &lt;start-line&gt; / span &lt;value&gt;;</li><li>grid-area: &lt;name&gt; | &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</li><li>justify-self: start | end | center | stretch;</li><li>align-self: start | end | center | stretch;</li><li>place-self: &lt;align-self&gt; / &lt;justify-self&gt;</li></ol><h3 id="简记"><a href="#简记" class="headerlink" title="简记"></a>简记</h3><p>  Grid的布局方式更像是Table，但比Table更灵活，因为Grid的Item可以任意定义在Grid Container的某个指定区域。比起Flex也是更加强大，Flex只是单纯的在主轴|交叉轴上定义一个比较模糊的布局方式，还是继承了比较传统的流的概念，Grid让你可以进行很精确的布局，而且Item可以重叠(z-index，这就有点像position)，就像是定好的格子在那里，Item想要那些完全可以自己选择。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Css </tag>
            
            <tag> Grid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS布局之Flex</title>
      <link href="/2020/04/28/CSS%E5%B8%83%E5%B1%80%E4%B9%8BFlex/"/>
      <url>/2020/04/28/CSS%E5%B8%83%E5%B1%80%E4%B9%8BFlex/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">https://css-tricks.com/snippets/css/a-guide-to-flexbox/</a></p></blockquote><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>  在不知道元素具体尺寸的情况下，提供一种更有效的布局手段，对齐方式，以及在容器的各项之间分配空间。</p><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><ol><li>flex container</li><li>flex item</li><li>主轴、交叉轴</li><li>main-statr/main-end、cross-start/cross-end</li><li>main-size、cross-size</li></ol><h3 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h3><ol><li>display: flex;</li><li>flex-direction: row(default) | row-reverse | column | column-reverse;</li><li>flex-wrap: nowrap(default) | wrap | wrap-reverse;</li><li>flex-flow: row(default) nowrap(default);<ul><li>flex-direction 和 flex-wrap的简写</li></ul></li><li>justify-content: flex-start(default) | flex-end | center | space-between | space-around | space-evenly | start | end | left | right … + safe | unsafe;<ul><li>start: item排列在writing-mode的方向</li><li>left: 和start很类似</li><li>Edge不支持space-between</li><li>chrome不支持start/end/left/right</li><li>可靠的值为：flex-start、flex-end 和 center</li><li>safe/unsafe ???<blockquote><p>There are also two additional keywords you can pair with these values: safe and unsafe. Using safe ensures that however you do this type of positioning, you can’t push an element such that it renders off-screen (e.g. off the top) in such a way the content can’t be scrolled too (called “data loss”).</p></blockquote></li></ul></li><li>align-items: stretch(default) | flex-start | flex-end | center | baseline | first baseline | last baseline | start | end | self-start | self-end + … safe | unsafe;<ul><li>stretch: 交叉轴填充容器</li><li>baseline：items基于baseline对齐</li><li>left、right、safe、unsafe、start、end：大多数浏览器不支持</li></ul></li><li>align-content: flex-start(default) | flex-end | center | space-between | space-around | space-evenly | stretch | start | end | baseline | first baseline | last baseline + … safe | unsafe;<ul><li>交叉轴上多行的对齐方式(justify-content是主轴上的对齐方式)</li><li>目标是轴，不是Item，注意和align-item的区别</li></ul></li></ol><hr><ol start="8"><li>order: 0(default);</li><li>flex-grow: 0(default);</li><li>flex-shrink: 0(default);</li><li>flex-basis: auto(default);<ul><li>设置flex item的初始值</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-basis" target="_blank" rel="noopener">MDN详细介绍</a></li></ul></li><li>flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]</li><li>align-self: auto | flex-start | flex-end | center | baseline | stretch;</li></ol><h3 id="其他一些资源"><a href="#其他一些资源" class="headerlink" title="其他一些资源"></a>其他一些资源</h3><ol><li><a href="https://bennettfeely.com/flexplorer/" target="_blank" rel="noopener">https://bennettfeely.com/flexplorer/</a></li><li><a href="https://bocoup.com/blog/dive-into-flexbox" target="_blank" rel="noopener">https://bocoup.com/blog/dive-into-flexbox</a></li><li><a href="https://www.w3.org/TR/css-flexbox-1/" target="_blank" rel="noopener">https://www.w3.org/TR/css-flexbox-1/</a></li></ol><h3 id="Bugs"><a href="#Bugs" class="headerlink" title="Bugs"></a>Bugs</h3><ol><li><a href="https://github.com/philipwalton/flexbugs" target="_blank" rel="noopener">https://github.com/philipwalton/flexbugs</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Css </tag>
            
            <tag> Flex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript之BasicTypes</title>
      <link href="/2020/04/28/TypeScript%E4%B9%8BBasicTypes/"/>
      <url>/2020/04/28/TypeScript%E4%B9%8BBasicTypes/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/basic-types.html</a></p></blockquote><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><p>  和Array很相似的类型，但Tuple的限制更多，有明确的的数量限制和各自元素对应的类型限制</p><h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><h3 id="Null-and-Undefined"><a href="#Null-and-Undefined" class="headerlink" title="Null and Undefined"></a>Null and Undefined</h3><h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h3 id="Type-assertions"><a href="#Type-assertions" class="headerlink" title="Type assertions"></a>Type assertions</h3><ul><li>“angle-bracket” 语法</li><li>as关键字</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript之UtilityTypes</title>
      <link href="/2020/04/28/TypeScript%E4%B9%8BUtilityTypes/"/>
      <url>/2020/04/28/TypeScript%E4%B9%8BUtilityTypes/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://www.typescriptlang.org/docs/handbook/utility-types.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/utility-types.html</a></p></blockquote><h3 id="Partial-lt-T-gt"><a href="#Partial-lt-T-gt" class="headerlink" title="Partial&lt;T&gt;"></a>Partial&lt;T&gt;</h3><p>  构造一个和T一样的类型，并使得其所有属性为可选的</p><h3 id="Readonly-lt-T-gt"><a href="#Readonly-lt-T-gt" class="headerlink" title="Readonly&lt;T&gt;"></a>Readonly&lt;T&gt;</h3><p>  构造一个和T一样的类型，并使得其所有属性为只读</p><h3 id="Record-lt-K-T-gt"><a href="#Record-lt-K-T-gt" class="headerlink" title="Record&lt;K,T&gt;"></a>Record&lt;K,T&gt;</h3><p>  构造一个拥有属性K，值(Type)为T的的类型</p><h3 id="Pick-lt-T-K-gt"><a href="#Pick-lt-T-K-gt" class="headerlink" title="Pick&lt;T,K&gt;"></a>Pick&lt;T,K&gt;</h3><p>  构造一个从T中取出一个集合K的类型</p><h3 id="Omit-lt-T-K-gt"><a href="#Omit-lt-T-K-gt" class="headerlink" title="Omit&lt;T,K&gt;"></a>Omit&lt;T,K&gt;</h3><p>  构造一个和T一样的类型，然后删除K，和Pick刚好相反</p><h3 id="Exclude-lt-T-U-gt"><a href="#Exclude-lt-T-U-gt" class="headerlink" title="Exclude&lt;T,U&gt;"></a>Exclude&lt;T,U&gt;</h3><p>  构造一个和T一样的类型，但不包含U（注意和Omit的区别）</p><h3 id="Extract-T-U-gt"><a href="#Extract-T-U-gt" class="headerlink" title="Extract;T,U&gt;"></a>Extract;T,U&gt;</h3><h3 id="NonNullable-lt-T-gt"><a href="#NonNullable-lt-T-gt" class="headerlink" title="NonNullable&lt;T&gt;"></a>NonNullable&lt;T&gt;</h3><h3 id="Parameters-lt-T-gt"><a href="#Parameters-lt-T-gt" class="headerlink" title="Parameters&lt;T&gt;"></a>Parameters&lt;T&gt;</h3><h3 id="ConstructorParameters-lt-T-gt"><a href="#ConstructorParameters-lt-T-gt" class="headerlink" title="ConstructorParameters&lt;T&gt;"></a>ConstructorParameters&lt;T&gt;</h3><h3 id="ReturnType-lt-T-gt"><a href="#ReturnType-lt-T-gt" class="headerlink" title="ReturnType&lt;T&gt;"></a>ReturnType&lt;T&gt;</h3><h3 id="InstanceType-lt-T-gt"><a href="#InstanceType-lt-T-gt" class="headerlink" title="InstanceType&lt;T&gt;"></a>InstanceType&lt;T&gt;</h3><h3 id="Required-lt-T-gt"><a href="#Required-lt-T-gt" class="headerlink" title="Required&lt;T&gt;"></a>Required&lt;T&gt;</h3><h3 id="ThisParameterType"><a href="#ThisParameterType" class="headerlink" title="ThisParameterType"></a>ThisParameterType</h3><h3 id="OmitThisParameter"><a href="#OmitThisParameter" class="headerlink" title="OmitThisParameter"></a>OmitThisParameter</h3><h3 id="ThisType-lt-T-gt"><a href="#ThisType-lt-T-gt" class="headerlink" title="ThisType&lt;T&gt;"></a>ThisType&lt;T&gt;</h3>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React如何知道一个函数是class？</title>
      <link href="/2020/04/27/React%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%98%AFclass%EF%BC%9F/"/>
      <url>/2020/04/27/React%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%98%AFclass%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://overreacted.io/how-does-react-tell-a-class-from-a-function/" target="_blank" rel="noopener">https://overreacted.io/how-does-react-tell-a-class-from-a-function/</a></p></blockquote><p>问题：当你调用一个组件时，&lt;ComponentName /&gt;，你不知道ComponentName是一个function或class(尤其是在浏览器环境中，它们都是函数，大多情况被babel编译，<a href="https://stackoverflow.com/questions/29093396/how-do-you-check-the-difference-between-an-ecmascript-6-class-and-function" target="_blank" rel="noopener">如何区别Class和Function？？</a>)，React内部需要做出区别，因为函数组件和类组件在React里是被区别对待的。</p><p>这个问题涉及到：new, this, class, arrow functions, prototype, <strong>proto</strong>, instanceof，还要考虑到被Babel编译后的情况。</p><ol><li>this和new</li><li>class和function<ul><li>class语法必须使用new操作符，否则会报错</li><li>大佬的这个表格很有必要：<table><thead><tr><th></th><th><code class="language-text">new Person()</code></th><th><code class="language-text">Person()</code></th></tr></thead><tbody><tr><td><code class="language-text">class</code></td><td>✅ <code class="language-text">this</code> is a <code class="language-text">Person</code> instance</td><td>🔴 <code class="language-text">TypeError</code></td></tr><tr><td><code class="language-text">function</code></td><td>✅ <code class="language-text">this</code> is a <code class="language-text">Person</code> instance</td><td>😳 <code class="language-text">this</code> is <code class="language-text">window</code> or <code class="language-text">undefined</code></td></tr></tbody></table></li></ul></li></ol><ol start="3"><li><p>为什么不直接使用new操作符(来执行所有的函数、类)</p><ul><li>箭头函数不能被new调用(箭头函数没有prototype，可以判断一个函数是否是箭头函数做差异化处理，但babel编译后不行)</li><li>React组件支持String和其他基本类型，但是使用new操作对于函数返回的基本类型会直接忽略而返回一个对象，这是因为new操作符的设计本身如此</li></ul></li><li><p>React到底是如何判断的呢？</p><ul><li>React.Component：当你编写Class组件时，必须继承React.Component，继承相关，prototype问题，instanceof关键词，可以通过判断是否继承React.Component来作为Class的依据，但当页面有多份React的拷贝时instanceof将不再可靠</li><li>Component.prototype.isReactComponent：所以目前React的做法是在React.Component的原型上加了判断依据(static properties 容易丢失)</li></ul></li></ol><blockquote><p>If the final API is successful, its users never have to think about this process.—— by Dan Abramov</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们为什么要使用super(props)</title>
      <link href="/2020/04/27/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8super/"/>
      <url>/2020/04/27/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8super/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://overreacted.io/why-do-we-write-super-props/" target="_blank" rel="noopener">https://overreacted.io/why-do-we-write-super-props/</a></p></blockquote><ol><li><p>为什么调用super() ?<br>答：调用super()后，才可以使用(parent定义的)this，所以如果你想在构造函数中使用this，Js会强制你首先调用super()函数</p></li><li><p>为什么传递props参数？<br>答：React会将props合并到实例（即使你仅仅调用super()），但是在合并之前(super - 构造函数结束)，你无法使用this.props。对于使用context的组件，你为什么不调用super(props, context)？？和props一个原理，context在构造函数中使用的场景更少。如果你不需要在构造函数里做一些额外的工作，只是声明state的话，可以使用class fields proposal，类似 state = {}，那就不会有super的问题</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/ Inside React</span><br><span class="line">class Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    this.props = props;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Inside your code</span><br><span class="line">class Button extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(); // 😬 We forgot to pass props</span><br><span class="line">    console.log(props);      // ✅ &#123;&#125;</span><br><span class="line">    console.log(this.props); // 😬 undefined </span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简记-2020-04-06</title>
      <link href="/2020/04/06/%E7%AE%80%E8%AE%B0-2020-04-06/"/>
      <url>/2020/04/06/%E7%AE%80%E8%AE%B0-2020-04-06/</url>
      
        <content type="html"><![CDATA[<ol><li>Symbol.hasInstance自定义instanceof操作</li><li>Babel Class 转ES5实现<ul><li>箭头函数被定义为对象(实例)本身的属性</li><li>非箭头函数被定义在构造函数的原型</li></ul></li><li>React this 丢失问题：<a href="https://reactjs.org/docs/faq-functions.html#why-is-binding-necessary-at-all" target="_blank" rel="noopener">https://reactjs.org/docs/faq-functions.html#why-is-binding-necessary-at-all</a><ul><li>事件处理时丢失</li><li>props传递时丢失</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何学习——自学5年的感悟</title>
      <link href="/2020/03/15/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%87%AA%E5%AD%A65%E5%B9%B4%E7%9A%84%E6%84%9F%E6%82%9F/"/>
      <url>/2020/03/15/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%87%AA%E5%AD%A65%E5%B9%B4%E7%9A%84%E6%84%9F%E6%82%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  今天翻过去的备忘录，看到了这样一句话：</p><blockquote><p>每次接触一个新东西时，要先知道怎么学，做好规划，不然很容易半路放弃。</p></blockquote><p>  算算从大三开始自学，到现在已经快有5年多了，期间学过Java、Html、CSS、JS、jQuery、数据结构、Node.js、Webpack、VueJS、React、Python、PS、Unity3D、Three.js……</p><h3 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h3><p>不管学什么，每个人肯定都有其目的，这是你学习的动机。享用知识的过程能使你感到快乐，但学习的过程是痛苦的，因为要耗费你的脑细胞去记忆新的概念，你一定要认识到这一点，然后克服它。</p><h3 id="资源整合"><a href="#资源整合" class="headerlink" title="资源整合"></a>资源整合</h3><p>要学一个新东西，必须对其整体有一个了解：</p><ol><li>背景历史（为什么存在？解决了什么问题？）</li><li>发展现状（有何重大核心改变？是否有相同的知识框架存在？差异性比较？）</li><li>可用资源整理：<ul><li>官网资源</li><li>图书出版</li><li>视频教程</li><li>社区博客</li></ul></li></ol><h3 id="学习计划（提醒事项）"><a href="#学习计划（提醒事项）" class="headerlink" title="学习计划（提醒事项）"></a>学习计划（提醒事项）</h3><ol><li>网上搜索是否有前辈的学习流程</li><li>根据自己的学习目的，考虑学习的深度<ul><li>仅限于使用</li><li>深度解读：一定要做笔记</li></ul></li><li>根据知识的分块，内容多少进行相应梳理</li><li>时间安排（ 提醒事项）</li><li>进度记录（周期更长的提醒事项）</li></ol><h3 id="问题记录（备忘录）"><a href="#问题记录（备忘录）" class="headerlink" title="问题记录（备忘录）"></a>问题记录（备忘录）</h3><ol><li>简单问题</li><li>复杂问题（都需记录在学习日记中）<ul><li>为什么会有这种问题？</li><li>如何解决？</li><li>解决方案？</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于一个庞大的知识体系，学习是一个漫长而又枯燥的过程，很容易半途而废，除非你在学习过程中能够找到运用它的乐趣。个人觉得学习计划是整个学习环节中最重要的一环，所以不要急于求成，一定要先明确学习计划，然后严格执行。相信等你到计划的最后一步时，回过头来看自己，肯定比预期还要收获的更多。</p><blockquote><p>多年后，菜鸟变成了大佬。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 如何学习 </tag>
            
            <tag> 自我管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Html 5 Drag API 实现一个可拖拽排序的列表</title>
      <link href="/2020/03/10/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Html-5-Drag-API-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%97%E8%A1%A8/"/>
      <url>/2020/03/10/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Html-5-Drag-API-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>项目中遇到一个需要拖拽排序的功能，稍微研究了下拖拽方面的东西。</p><p>针对React比较流行的库有：</p><ol><li>react-draggable: 纯粹使用transform进行移动，pass掉</li><li>react-dnd：基于h5拖放API，OK</li></ol><p>接着便开始着手研究react-dnd的文档，稍微有点复杂，核心还是把元素的拖拽行为变为数据的拖拽行为，符合React的一贯作风。<br>但我觉得就一个排序的拖拽，这个库有稍微有点复杂了。而且库本身体积还挺大的(746 kB)，于是就放弃了，开始直接研究原始的API。</p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><ol><li><p>ondragstart<br>对可拖拽的目标注册ondragstart事件，记录该目标的索引</p></li><li><p>ondragover<br>对投放目标添加ondragover事件，并将元素索引绑定至data-index，<br>接着在事件函数里判断被拖拽的元素索引和当前投放目标的索引(此处要注意event.target和event.currentTarget的区别)，<br>并未其添加相应hover样式。</p></li><li><p>ondragleave<br>还要对投放目标添加ondragleave事件，这个是和ondragover事件相对应起来的，需要将ondragover里做的一些事情复原，比如样式的改动</p></li><li><p>ondrop<br>最后一步就是目标投放，还是为投放目标添加ondrop事件，然后在ondrop事件里可以拿到当前投放的索引，以及之前在ondragstart事件里记录的被拖拽索引。<br>接着就是改变列表list的顺序就可以了。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> HTML 5 拖放 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>借助Hooks API创建局部模块类Redux的数据流</title>
      <link href="/2020/03/08/%E5%80%9F%E5%8A%A9Hooks-API%E5%88%9B%E5%BB%BA%E5%B1%80%E9%83%A8%E6%A8%A1%E5%9D%97%E7%B1%BBRedux%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
      <url>/2020/03/08/%E5%80%9F%E5%8A%A9Hooks-API%E5%88%9B%E5%BB%BA%E5%B1%80%E9%83%A8%E6%A8%A1%E5%9D%97%E7%B1%BBRedux%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>目前做的项目每个模块都单独分离，不再和整体应用内聚，所以在对redux等全局工具的使用上就显得有些笨手笨脚。纵使模块高度分离，但是大部分的模块应用复杂度仍然很高。</p><p>之前一直使用contex来管理模块顶层数据，但这会使模块顶层组件变得臃肿难懂。</p><p>最近研究了下Hooks API，觉得非常符合现在的开发模式，因为借助useReducer和contex可以基本实现一个局部的类redux的开发流程，以使得单个模块内有清晰的数据流。</p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p><img alt data-src="/images/react-hooks-pratice.png"></p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p><a href="https://github.com/iWuzhi/react-hooks-practice" target="_blank" rel="noopener">https://github.com/iWuzhi/react-hooks-practice</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> React Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>antd#Form bug</title>
      <link href="/2020/03/07/antd-form-bug/"/>
      <url>/2020/03/07/antd-form-bug/</url>
      
        <content type="html"><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>Antd#Form.getFieldDecorator使用nodeName作为表单字段时，会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: element.nodeName.toLowerCase is not a function</span><br></pre></td></tr></table></figure><h3 id="如何重现"><a href="#如何重现" class="headerlink" title="如何重现"></a>如何重现</h3><p><a href="https://github.com/iWuzhi/antd-form-bug" target="_blank" rel="noopener">https://github.com/iWuzhi/antd-form-bug</a></p><h3 id="已知issue"><a href="#已知issue" class="headerlink" title="已知issue"></a>已知issue</h3><ol><li><p><a href="https://github.com/ant-design/ant-design/issues?q=nodeName" target="_blank" rel="noopener">https://github.com/ant-design/ant-design/issues?q=nodeName</a></p></li><li><p><a href="https://github.com/facebook/react/issues/6284" target="_blank" rel="noopener">https://github.com/facebook/react/issues/6284</a></p></li></ol><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p> <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement</a></p><pre><code>对于HTMLFormElement可以通过id或name获取Form下的一个表单项(Input, Select等)，当id或name为nodeName时，会覆盖HTMLFormElement原有的nodeName属性即：&apos;FORM&apos; =&gt; Element将一个字符串类型改为一个Element节点所以调用toLowerCase报错</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Antd </tag>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020，继续</title>
      <link href="/2020/03/02/2020%EF%BC%8C%E7%BB%A7%E7%BB%AD/"/>
      <url>/2020/03/02/2020%EF%BC%8C%E7%BB%A7%E7%BB%AD/</url>
      
        <content type="html"><![CDATA[<p>回家时没有带电脑</p><p>疫情期间一个月的空白</p><p>但也不是什么都没干</p><p>回家时带了三本书：两本计算机网络、一本程序员的数学</p><p>返程时多了两个笔记本，带不动了，书现在还在路上</p><p>等书到了，再梳理补下</p><p>疫情断点</p><p>2020，继续</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令记录</title>
      <link href="/2020/01/18/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/01/18/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><ol><li>git config – global user.name/email</li><li>git config –global alias.visual ‘!gitk’（别名配置，方便快速使用一些繁琐或不方便记忆的命令）</li></ol><h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><ol><li>git help &lt;verb&gt;</li></ol><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol><li>git init</li><li>git clone</li></ol><h3 id="基础-操作"><a href="#基础-操作" class="headerlink" title="基础 操作"></a>基础 操作</h3><ol><li><p>git status（当前状态，未跟踪、未改变、已改变、已暂存）</p></li><li><p>git add</p></li><li><p>git commit</p><ul><li><p>git commit -m &#39;message&#39;</p></li><li><p>git commit -a -m &#39;message&#39;</p></li></ul></li><li><p>git rm</p><ul><li>git rm –cache（不删除已存在文件，新增.gitignore时很有用）</li></ul></li><li><p>git log</p><ul><li>git log -p</li><li>git log –oneline</li><li>git log –stat</li></ul></li></ol><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><ol><li>git commit –amend（忘记提交一些东西或者提交message错误时很有用）</li><li>git reset（常见的git reset HEAD，取消暂存）</li><li>git checkout –（文件恢复）</li></ol><h3 id="忽略文件-gitignore"><a href="#忽略文件-gitignore" class="headerlink" title="忽略文件(.gitignore)"></a>忽略文件(.gitignore)</h3><ol><li>文件格式</li><li>glob（文件）匹配模式</li><li>匹配注意事项：如开头/防止递归</li></ol><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ol><li><p>SSH key: ssh-keygen</p></li><li><p>git remote</p><ul><li>git remote -v（所有本地到远程仓库的映射）</li><li>git remote add（一个已存在的本地项目初始化时经常用到）</li><li>git remote rename（远程地址变更时）</li><li>git remote rm（远程地址变更时）</li></ul></li><li><p>git fetch</p></li><li><p>git push</p></li><li><p>git pull（fetch + merge）</p></li></ol><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ol><li>git branch<ul><li>git branch -d 本地分支（删除本地分支）</li><li>git push origin :远程分支（删除远程分支）</li><li>git branch -v/-a</li><li>git fetch origin :远程分支（会在本地新建一个分支）</li></ul></li><li>git checkout<ul><li>git checkout 分支</li><li>git checkout -b 分支</li></ul></li><li>git merge/rebase（分支合并）</li><li>git cherry-pick（随意pick一些离散的commit）</li></ol><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><ol><li>git tag<ul><li>git tag -a version -m ‘message’（当前HEAD）</li><li>git tag -a version 某个提交（某个commit）</li><li>git push –tags</li><li>git tag -d 标签（删除本地）</li><li>git push origin :refs/tags/标签（远程）</li><li>git checkout -b 分支名 标签（从标签检出分支）</li></ul></li></ol><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><ol><li>HEAD分离</li><li>^相对HEAD移动，后面加数字表示第几个父节点（merge会有多余一个节点可能）</li><li>~相对HEAD移动，后面加数字表示移动位置</li></ol><h3 id="Git-Hooks"><a href="#Git-Hooks" class="headerlink" title="Git Hooks"></a>Git Hooks</h3><ol><li>git规范</li></ol><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><ol><li>Git官网：<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2</a></li><li>一个可视化闯关式练习：<a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">https://learngitbranching.js.org/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React文档阅读之Hooks</title>
      <link href="/2020/01/12/React%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BHooks/"/>
      <url>/2020/01/12/React%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BHooks/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Hooks是在16.8新增的功能，它们能够让你在没有Class的情况下使用state和其他React功能。</p><h3 id="为什么要新增Hooks？"><a href="#为什么要新增Hooks？" class="headerlink" title="为什么要新增Hooks？"></a>为什么要新增Hooks？</h3><ol><li>组件之间难以共享状态逻辑(props + HOC，wrapper hell)</li><li>复杂组件难以理解（重复的逻辑，初始化/更新/卸载）</li><li>JavaScript class机制对于人们造成的误解（this指向）</li></ol><h3 id="我该什么时候使用Hooks？"><a href="#我该什么时候使用Hooks？" class="headerlink" title="我该什么时候使用Hooks？"></a>我该什么时候使用Hooks？</h3><ol><li>如果你喜欢Hooks，可以在新增的功能产品上使用Hooks</li><li>不建议将以前的代码全部重写</li></ol><h3 id="Hooks概览"><a href="#Hooks概览" class="headerlink" title="Hooks概览"></a>Hooks概览</h3><ol><li>State Hook: useState()</li><li>Effect Hook: useEffect()</li><li>Hooks规则：<ul><li>只允许在函数顶层使用Hooks，不允许在条件、循环、内部函数里使用</li><li>只允许在函数组件或自定义的Hooks里调用Hooks</li><li>可以使用linter pluginl避免违反上面规则</li></ul></li><li>创建你自己的Hooks(自定义Hooks)</li><li>其他Hooks<ul><li>useContext</li><li>useReducer</li></ul></li></ol><h3 id="使用State-Hook（useState-干了什么？）"><a href="#使用State-Hook（useState-干了什么？）" class="headerlink" title="使用State Hook（useState()干了什么？）"></a>使用State Hook（useState()干了什么？）</h3><ol><li>声明一个状态变量，这个变量会被React存储</li><li>useState(‘hello’)，hello是该状态变量的默认值</li><li>useState()返回一个数组，[state, setState]，state表示这个状态变量，setState用来更新这个状态变量</li><li>可以通过多次调用useState()函数以声明多个状态变量</li></ol><h3 id="Effect-Hook（useEffect-干了什么？）"><a href="#Effect-Hook（useEffect-干了什么？）" class="headerlink" title="Effect Hook（useEffect()干了什么？）"></a>Effect Hook（useEffect()干了什么？）</h3><ol><li>Effect Hook可以让你在函数组件里执行一些副作用的操作，比如数据获取、手动更新DOM等</li><li>useEffect()会在每次render的时候都会重新调用(可能会有性能问题)</li><li>useEffect()第二个参数可以用来控制是否在render的过程中重新执行</li><li>可以在回调函数里返回一个卸载函数（就像componentWillUnmount）,不像class，这种返回函数的写法可以将某个逻辑中注册和清除的工作放在一起</li><li>可以使用Effect Hook将逻辑分割成不同的自定义Hook，已达到代码分割及复用的目的</li></ol><h3 id="Hooks规则（为什么会有这些规则）"><a href="#Hooks规则（为什么会有这些规则）" class="headerlink" title="Hooks规则（为什么会有这些规则）"></a>Hooks规则（为什么会有这些规则）</h3><blockquote><p>React依赖于Hooks的调用顺序</p></blockquote><p>我们在声明一个状态变量的时候，没有给定一个key或者其他的唯一标识。React会存储我们声明的状态变量，每次render之后，再次调用useState()会根据调用次序正确返回已存储的状态变量。</p><h3 id="构建你自己的Hooks"><a href="#构建你自己的Hooks" class="headerlink" title="构建你自己的Hooks"></a>构建你自己的Hooks</h3><ol><li>一个Hooks可以返回一个状态值（类似state），且这个值可变，而改变的逻辑就在定义这个Hooks的函数中</li><li>一般自定义最底层的Hooks都会用到系统Hooks（useState、useEffect等）</li><li>下面是<a href="http://jsfiddle.net/avbqfcm7/4/" target="_blank" rel="noopener">一个简单的例子</a>：</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; useState, useEffect &#125; = React;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> [time, setTime] = useState();</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTime(<span class="built_in">Date</span>.now());</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyHooks</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> time = useTime();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  &lt;h3&gt;&#123;time&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class TodoApp extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;MyHooks /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;TodoApp /</span>&gt;, <span class="built_in">document</span>.querySelector(<span class="string">"#app"</span>))</span><br></pre></td></tr></table></figure><h3 id="Hooks-API引用"><a href="#Hooks-API引用" class="headerlink" title="Hooks API引用"></a>Hooks API引用</h3><ol><li>基础Hooks<ul><li>useState</li><li>useEffect</li><li>useContext</li></ul></li><li>其它Hooks<ul><li>useReducer</li><li>useCallback</li><li>useMemo</li><li>useRef</li><li>useImperativeHandle</li><li>useLayoutEffect</li><li>useDebugValue</li></ul></li></ol><h3 id="Hooks-FAQ"><a href="#Hooks-FAQ" class="headerlink" title="Hooks FAQ"></a>Hooks FAQ</h3><ul><li>使用策略<ol><li>版本：16.8</li><li>当前Hooks并未覆盖所有的class场景，如getSnapshotBeforeUpdate、componentDidCatch生命周期，还有部分三方库可能不支持</li><li>和Redux集成，React Redux since v7.1.0已经支持Hooks方式，之前版本可仍使用以前的方式</li><li>静态类型：Flow和TypeScript React定义已经支持React Hooks</li><li>测试使用Hooks的组件</li><li>lint 规则强制做了哪些：<ol><li>Hooks本身在一个函数组件或另一个Hooks里</li><li>Hooks每次调用顺序不会变</li></ol></li></ol></li><li>从Classes到Hooks<ol><li>生命周期映射</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
            <tag> React文档阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一周总结（2019-01-06~2020-01-12）</title>
      <link href="/2020/01/12/%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%882019-01-06-2020-01-12%EF%BC%89/"/>
      <url>/2020/01/12/%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%882019-01-06-2020-01-12%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="主线任务"><a href="#主线任务" class="headerlink" title="主线任务"></a>主线任务</h3><ol><li><a href="tags/我如何写React代码/">React应用场景思考</a></li><li><a href="[http://127.0.0.1:4000/tags/ES%E7%89%88%E6%9C%AC/](http://127.0.0.1:4000/tags/ES版本/)">ECMA版本总结</a></li><li>MDN网站记忆</li></ol><h3 id="副本任务"><a href="#副本任务" class="headerlink" title="副本任务"></a>副本任务</h3><ol><li><a href="tags/程序员的数学/">《程序员的数学》列入计划</a></li><li>flutter日常练习（接下来会搁置一段时间，时间上不允许，优先级降低）<ul><li>语言基础</li><li>布局方式</li><li>常用Widget</li></ul></li><li>leetcode刷题：字符串、链表</li></ol><h3 id="每周任务"><a href="#每周任务" class="headerlink" title="每周任务"></a>每周任务</h3><ol><li><a href="tags/正则表达式/">正则表达式</a>（接下来可能会延长周期至月）</li><li>vim快捷键复习（接下来可能会延长周期至月）</li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>http协议：做了简单规划，接下来会列入日常任务</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 一周总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一周资讯总结（2019-01-06~2019-01-12）</title>
      <link href="/2020/01/12/%E4%B8%80%E5%91%A8%E8%B5%84%E8%AE%AF%E6%80%BB%E7%BB%93%EF%BC%882019-01-06-2019-01-12%EF%BC%89/"/>
      <url>/2020/01/12/%E4%B8%80%E5%91%A8%E8%B5%84%E8%AE%AF%E6%80%BB%E7%BB%93%EF%BC%882019-01-06-2019-01-12%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="（来源）twitter"><a href="#（来源）twitter" class="headerlink" title="（来源）twitter"></a>（来源）twitter</h3><ol><li>Puppeteer: <a href="https://www.npmjs.com/package/puppeteer" target="_blank" rel="noopener">https://www.npmjs.com/package/puppeteer</a></li><li>几篇关于浏览器原理的文章：<ul><li><a href="https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/" target="_blank" rel="noopener">https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/</a></li><li><a href="https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.g60f92a5151_40_120" target="_blank" rel="noopener">https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.g60f92a5151_40_120</a></li><li><a href="https://developers.google.com/web/updates/2018/09/inside-browser-part1" target="_blank" rel="noopener">https://developers.google.com/web/updates/2018/09/inside-browser-part1</a></li></ul></li><li>babel/7.8.0(ESMAScript 2020): <a href="https://babeljs.io/blog/2020/01/11/7.8.0" target="_blank" rel="noopener">https://babeljs.io/blog/2020/01/11/7.8.0</a></li><li>2019JavaScript Rising Stars: <a href="https://risingstars.js.org/2019/en/" target="_blank" rel="noopener">https://risingstars.js.org/2019/en/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 一周总结 </tag>
            
            <tag> 资讯总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式每周练习之RegexGolf</title>
      <link href="/2020/01/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%AF%8F%E5%91%A8%E7%BB%83%E4%B9%A0%E4%B9%8BRegexGolf/"/>
      <url>/2020/01/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%AF%8F%E5%91%A8%E7%BB%83%E4%B9%A0%E4%B9%8BRegexGolf/</url>
      
        <content type="html"><![CDATA[<h3 id="关于RegexGolf"><a href="#关于RegexGolf" class="headerlink" title="关于RegexGolf"></a>关于RegexGolf</h3><p><a href="https://alf.nu/RegexGolf" target="_blank" rel="noopener">RegexGolf</a>是一个很不错的练习正则表达式的在线网站。</p><h3 id="练习记录"><a href="#练习记录" class="headerlink" title="练习记录"></a>练习记录</h3><ol><li><strong>Warmup</strong>：foo</li><li><strong>Anchors</strong>：k$</li><li><strong>It never ends</strong>：u\b</li><li><strong>Ranges</strong>：^[a-f]*$</li><li><strong>Backrefs</strong>：(…)\w*\1</li><li><strong>Abba</strong>：^(?!.*(.)(.)\2\1)</li><li><strong>A man, a plan</strong>：^(.)(.).*\2\1$</li><li><strong>Prime</strong>：^(?!(xx+)\1+$)</li><li><strong>Four</strong>： (.)(.\1){3}</li><li><strong>Order</strong>：^.{5}[^e]?$</li></ol><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>后面几道题有点变态，后面刷</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的数学2概率统计》读书笔记</title>
      <link href="/2020/01/09/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%A62%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/09/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%A62%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="第一部分-聊聊概率这件事"><a href="#第一部分-聊聊概率这件事" class="headerlink" title="第一部分 聊聊概率这件事"></a>第一部分 聊聊概率这件事</h3><h5 id="第一章-概率的定义"><a href="#第一章-概率的定义" class="headerlink" title="第一章 概率的定义"></a>第一章 概率的定义</h5><ol><li><p>三扇门（蒙题霍尔问题）<a href="[https://baike.baidu.com/item/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/1242689?fr=aladdin](https://baike.baidu.com/item/三门问题/1242689?fr=aladdin)">百度链接</a></p><p>如果我们太执着于结果，即在主持人打开一扇错误的门时，我们便立刻将这扇错误的门排除在外，得到结论：剩下的两扇门正确或错误各1/2。而如果我们站在起点考虑，第一次选择错误的概率为2/3，主持人将剩余两扇门再排除其中错误的一个，即第一次假定自己选择错误，那么重新选择必将获得正确的结果，概率为2/3。</p><p>书中总结道：</p><blockquote><ol><li>问题：考虑有100扇门而主持人将打开其中98扇的情况</li><li>对于某个特定的世界（ω）来说，所有的结果都已确定，不存在任何随机事件。</li><li>每个世界结果完全确定，然而人们无法知晓自己住在哪个世界</li><li>将概率问题转化为完全确定的面积问题</li><li>三元组（Ω，Ϝ，P）ω表示具体的某一个世界，Ω表示所有平行世界组成的集合</li></ol></blockquote></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 程序员的数学 </tag>
            
            <tag> 程序员的数学2概率统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES版本解读总结</title>
      <link href="/2020/01/07/ES%E7%89%88%E6%9C%AC%E8%A7%A3%E8%AF%BB%E6%80%BB%E7%BB%93/"/>
      <url>/2020/01/07/ES%E7%89%88%E6%9C%AC%E8%A7%A3%E8%AF%BB%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>从ES5以来，ES6(ECMAScript 2015)这个版本是变化内容最大的一次，之后的版本变化都较小。</p><p>自己这边几篇文章都是跑脚本自动生成的：</p><p><a href="/tags/ES版本">ES版本解读系列</a></p><p>然后今天在Twitter上刷到一篇总结的很不错的文章：<a href="https://inspiredwebdev.com/everything-from-es-2016-to-es-2019#section_11" target="_blank" rel="noopener">https://inspiredwebdev.com/everything-from-es-2016-to-es-2019#section_11</a></p><p>所以自己在ES版本方面的了解要告一段落了，有空直接去看上面链接就好了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> ES版本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我如何写React代码之Context</title>
      <link href="/2020/01/06/%E6%88%91%E5%A6%82%E4%BD%95%E5%86%99React%E4%BB%A3%E7%A0%81%E4%B9%8BContext/"/>
      <url>/2020/01/06/%E6%88%91%E5%A6%82%E4%BD%95%E5%86%99React%E4%BB%A3%E7%A0%81%E4%B9%8BContext/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><a href="/2020/01/03/我如何写React代码之原始人/">我如何写React代码之原始人</a></p><h3 id="我该用Context吗？"><a href="#我该用Context吗？" class="headerlink" title="我该用Context吗？"></a>我该用Context吗？</h3><ol><li><p><a href="https://reactjs.org/docs/context.html" target="_blank" rel="noopener">https://reactjs.org/docs/context.html</a></p></li><li><p><a href="https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076" target="_blank" rel="noopener">https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076</a></p></li></ol><h3 id="Context能做什么？"><a href="#Context能做什么？" class="headerlink" title="Context能做什么？"></a>Context能做什么？</h3><blockquote><p>Context provides a way to pass data through the component tree without having to pass props down manually at every level.</p></blockquote><p>所以在需要对子组件传递一些props，而且嵌套比较深的时候，可以考虑使用Context.</p><h3 id="我该如何使用？"><a href="#我该如何使用？" class="headerlink" title="我该如何使用？"></a>我该如何使用？</h3><p><img alt="图" data-src="/images/2020-01-06_22-42-58.png"></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>只要Provider的value变化consumers就会重新渲染，和shouldComponentUpdate没有关系</li><li>Provider的value是否变化的算法和Object.is()一致@<a href="https://reactjs.org/docs/context.html#caveats" target="_blank" rel="noopener">可能会遇到的问题</a></li><li>React.Component.contextType属性：<ul><li>因为context是react内置的API，所以这个属性也相当于是给Context的使用(consumer)提供了一种简洁的方式</li><li>限制：只会使用最近Provider提供的value值，且只能使用这一个Context</li></ul></li><li>Context.Consumer<ul><li>这个是堂堂正正的ContextAPI，以函数回调的方式订阅context的变化，可以通过多层嵌套使用不同Provider提供的context</li><li>缺点：没有contextType那么简洁</li></ul></li></ol><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ol><li>React router是如何使用ContextAPI的？</li><li>Redux和Context如何选择</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
            <tag> 我如何写React代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一周总结（2019-12-30~2020-01-05）</title>
      <link href="/2020/01/05/%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%882019-12-30-2020-01-05%EF%BC%89/"/>
      <url>/2020/01/05/%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%882019-12-30-2020-01-05%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="主线任务"><a href="#主线任务" class="headerlink" title="主线任务"></a>主线任务</h3><ol><li><a href="/tags/ES版本/">ES版本解读</a></li><li>MDN JS API 日常训练</li><li><a href="/tags/Flutter">Flutter</a>日常练习</li><li><a href="/tags/我如何写React代码/">关于React的一些感悟</a></li></ol><h3 id="副本剧情"><a href="#副本剧情" class="headerlink" title="副本剧情"></a>副本剧情</h3><ol><li><a href="2020/01/01/我如何从MDN文档分析ESMAScript版本信息/">网页爬虫体验</a></li><li>React源码(React.Context如何实现)</li><li>LeetCode刷题（字符串刷完了）</li><li><a href="http://106.13.230.115:8081/" target="_blank" rel="noopener">Unity3D尝试</a></li></ol><h3 id="周期训练"><a href="#周期训练" class="headerlink" title="周期训练"></a>周期训练</h3><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">正则表达式</a><ul><li>捕获括号：如何使用\1\2…捕获进行重复匹配（经典示例：回文串）</li><li>RegExp.exec: 全局匹配模式下如何遍历得到所有匹配结果</li></ul></li><li>vim练习：常用快捷键练习</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 一周总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一周资讯总结（2019-12-30~2020-01-05）</title>
      <link href="/2020/01/04/%E4%B8%80%E5%91%A8%E8%B5%84%E8%AE%AF%E6%80%BB%E7%BB%93%EF%BC%882019-12-30-2020-01-05%EF%BC%89/"/>
      <url>/2020/01/04/%E4%B8%80%E5%91%A8%E8%B5%84%E8%AE%AF%E6%80%BB%E7%BB%93%EF%BC%882019-12-30-2020-01-05%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="（来源）Twitter"><a href="#（来源）Twitter" class="headerlink" title="（来源）Twitter"></a>（来源）Twitter</h3><ol><li>XState(内容和redux有点像)：<a href="https://xstate.js.org/" target="_blank" rel="noopener">https://xstate.js.org/</a></li><li>Jenkins X：<a href="https://jenkins-x.io/" target="_blank" rel="noopener">https://jenkins-x.io/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 一周总结 </tag>
            
            <tag> 资讯总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我如何写React代码之原始人</title>
      <link href="/2020/01/03/%E6%88%91%E5%A6%82%E4%BD%95%E5%86%99React%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%8E%9F%E5%A7%8B%E4%BA%BA/"/>
      <url>/2020/01/03/%E6%88%91%E5%A6%82%E4%BD%95%E5%86%99React%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%8E%9F%E5%A7%8B%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因为前一段时间的一些经历，让我想了很多。现在敲代码都是要多加一道工序，不仅仅满足于：我用这个API可以实现这个功能，而是要问自己：我为什么要用这个API或这种方式去实现这个功能？带着问题写业务的这段时间，感触比较多，所以想在此记录下。</p><h3 id="有新需求了"><a href="#有新需求了" class="headerlink" title="有新需求了"></a>有新需求了</h3><p>下图是一个很常见的PC布局：</p><p><img alt="图片" data-src="/images/2020-01-03_20-05-40.png"></p><p>React的核心思想就是组件化，开发时可以将功能或UI划分成不同的小型组件，然后再组合在一起完成完整的业务功能。每个小组件都只负责某一块功能的实现和交互，这对于多人协作（任务分配），以及后期维护（每个组件的功能单一）都是非常具有优势的。</p><p>看到（第一眼）视觉稿的我，在心里已经将其大卸八块，正如上图所标示的那样，某某组件、某某组件…Perfect !</p><h3 id="终于要码代码了，Go"><a href="#终于要码代码了，Go" class="headerlink" title="终于要码代码了，Go"></a>终于要码代码了，Go</h3><p>接着就要开始专注于其中的一个’某某组件’了。这时主要关注的就以下这些问题了：</p><ol><li>这个组件需要哪些state，又需要哪些props？</li><li>生命周期有必要使用吗？（业务需要）</li><li>我要用React.Compoent还是React.PureComponent?</li><li>我要用function还是class？</li><li>UI展示/CSS相关（忽略）</li><li>基本元素使用/HTML相关（忽略）</li></ol><h3 id="该组合这些小玩意了"><a href="#该组合这些小玩意了" class="headerlink" title="该组合这些小玩意了"></a>该组合这些小玩意了</h3><p>上知需求文档，下晓交互视觉，很快将剩下的小零件都设计并开发完了。接着就需要一些容器组件如Layout之类的来组合这些小零件了。这时你就会发现，在一个非常底层的某个小零件需要的props却要在或许是最顶层的容器组件中作为state来管理，如下图：</p><p><img alt="图片" data-src="/images/2020-01-03_20-44-57.png"></p><p>因为props要必须要一层一层的传递下来，所以或许会破坏中间某些容器组件或其他高级组件（组合组件）的设计合理性，因为要强行增加一个或许不需要的props。</p><p>一两个这种情况或许还能忍受，但如果传递的props比较多的话，会特别麻烦，所以有些人就干脆不零件化了，干脆整个页面/或某一个功能就是一个单独的组件，没有props。这个组件管理着所有的state（我见过有很多人就是这样写代码的，常常一份文件就有4、500行代码），这其实会造成一个更大的问题，随着业务的更新迭代，代码会变得越来越难维护。</p><p>这其实就相当于是一种的逃避的行为，因为我们的问题是props如何传递，而不是不需要更细更小的组件，我们需要它，因为它很完美（功能单一，props传递和小组件本身没有关系）。</p><h3 id="我该怎么办"><a href="#我该怎么办" class="headerlink" title="我该怎么办"></a>我该怎么办</h3><p>在没有context、没有redux的世界，我选择的是props传递的痛苦，因为我根本无法忍受所有混杂的state放在一起，无论是命名冲突还是查找使用，都会带来极大的不便。或许你可以通过事件机制，像addEventListener()那样，在需要管理state的容器组件里添加事件，然后在小零件里触发事件去更新state，这样可以减少props更新(方法)的传递，也或许可以以同样的方式将小零件的state和容器组件的state做同步，这样就直接不用传递props。这种事件的机制，其实已经和Redux的Connect很像了，只是state的存储位置以及更新方式不同。</p><h3 id="进击的原始人"><a href="#进击的原始人" class="headerlink" title="进击的原始人"></a>进击的原始人</h3><p>下一篇：<a href>我如何写React代码之Context</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
            <tag> 我如何写React代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常使用工具记录</title>
      <link href="/2020/01/01/%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/01/01/%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="网页抓取"><a href="#网页抓取" class="headerlink" title="网页抓取"></a>网页抓取</h3><ol><li>superagent：HTTP客户端</li><li>cheerio：像jQuery一样分析网页</li></ol><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><ol><li>nodemon：热重载</li><li>fs-extra：更加简洁的文件读写API</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 日常工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我如何从MDN文档分析ESMAScript版本信息</title>
      <link href="/2020/01/01/%E6%88%91%E5%A6%82%E4%BD%95%E4%BB%8EMDN%E6%96%87%E6%A1%A3%E5%88%86%E6%9E%90ESMAScript%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF/"/>
      <url>/2020/01/01/%E6%88%91%E5%A6%82%E4%BD%95%E4%BB%8EMDN%E6%96%87%E6%A1%A3%E5%88%86%E6%9E%90ESMAScript%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>想整理下JavaScript各个版本的changelog，但找了很多资料都没有一个有效的方式。ESMA规范没有找到相关变更变化，只能追踪最近的版本日志。网上其他的ES6版本中都插入了或多或少的其他版本（如阮一峰ES6）。最后想手动整理，但感觉有点多，再结合自己目前的整理方式（读MDN API，然后校对相应版本再记录），直接写了这个脚本从MDN拉数据了，然后再将其转换成MD格式即可。</p><p>考虑到目的，目前需要做的事情：</p><ol><li><p>从MDN拉取HTML文档</p></li><li><p>解析相应元素，获得版本信息</p></li><li><p>转换成markdown格式</p></li></ol><p>找了以下三方库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;fs-extra&quot;: &quot;^8.1.0&quot;,  // 读写文件</span><br><span class="line">&quot;superagent&quot;: &quot;^5.1.3&quot;  // 用于读取网页客户端</span><br><span class="line">&quot;nodemon&quot;: &quot;^2.0.2&quot;  // 方便开发环境调试</span><br><span class="line">&quot;cheerio&quot;: &quot;^1.0.0-rc.3&quot;,  // 像jQuery一样获取DOM元素</span><br></pre></td></tr></table></figure><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ol><li><p>版本要求：</p><blockquote><p> node:  &gt; v12.6.0</p></blockquote></li><li><p>获取代码：</p><blockquote><p>git clone git@github.com:iWuzhi/es-script-version.git</p></blockquote></li><li><p>安装依赖：</p><blockquote><p>npm i</p></blockquote></li><li><p>抓取原始数据：</p><blockquote><p>npm run fetch</p></blockquote></li><li><p>markdown文件生成：</p><blockquote><p>npm run revert</p></blockquote></li></ol><h3 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h3><ol><li><p>ESMA_XXXXStore.js：从MDM拉取的原始HTML构造的JSON数据</p></li><li><p>ESMA_XXXXStore.md: 对应版本的目标文件(markdown格式)</p></li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>目前只拉取了内置对象这一大模块，其中部分API貌似没有拉取成功。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整体还需要再校对一次，毕竟目的是学习记忆，而不是单纯的记录版本信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> ES版本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript版本拾荒记——ES2015</title>
      <link href="/2019/12/30/JavaScript%E7%89%88%E6%9C%AC%E6%8B%BE%E8%8D%92%E8%AE%B0%E2%80%94%E2%80%94ES2015/"/>
      <url>/2019/12/30/JavaScript%E7%89%88%E6%9C%AC%E6%8B%BE%E8%8D%92%E8%AE%B0%E2%80%94%E2%80%94ES2015/</url>
      
        <content type="html"><![CDATA[<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><ol><li>Array.from</li><li>Array.of</li><li>Array.copyWithin</li><li>Array.entries</li><li>Array.fill</li><li>Array.find</li><li>Array.findIndex</li><li>Array.forEach</li><li>Array.keys</li><li>Array.values</li><li>Array.@@iterator</li><li>Array.@@species</li></ol><h1 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h1><ol><li>ArrayBuffer.isView</li><li>ArrayBuffer.slice</li></ol><h1 id="BigUint64Array"><a href="#BigUint64Array" class="headerlink" title="BigUint64Array"></a>BigUint64Array</h1><ol><li>BigUint64Array.from</li><li>BigUint64Array.of</li><li>BigUint64Array.copyWithin</li><li>BigUint64Array.entries</li><li>BigUint64Array.every</li><li>BigUint64Array.fill</li><li>BigUint64Array.filter</li><li>BigUint64Array.find</li><li>BigUint64Array.findIndex</li><li>BigUint64Array.forEach</li><li>BigUint64Array.indexOf</li><li>BigUint64Array.join</li><li>BigUint64Array.keys</li><li>BigUint64Array.lastIndexOf</li><li>BigUint64Array.map</li><li>BigUint64Array.reduce</li><li>BigUint64Array.reduceRight</li><li>BigUint64Array.reverse</li><li>BigUint64Array.set</li><li>BigUint64Array.slice</li><li>BigUint64Array.some</li><li>BigUint64Array.sort</li><li>BigUint64Array.subarray</li><li>BigUint64Array.toLocaleString</li><li>BigUint64Array.toString</li><li>BigUint64Array.values</li><li>BigUint64Array.@@iterator</li></ol><h1 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h1><ol><li>DataView.getFloat32</li><li>DataView.getFloat64</li><li>DataView.getInt16</li><li>DataView.getInt32</li><li>DataView.getInt8</li><li>DataView.getUint16</li><li>DataView.getUint32</li><li>DataView.getUint8</li><li>DataView.setFloat32</li><li>DataView.setFloat64</li><li>DataView.setInt16</li><li>DataView.setInt32</li><li>DataView.setInt8</li><li>DataView.setUint16</li><li>DataView.setUint32</li><li>DataView.setUint8</li></ol><h1 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h1><ol><li>Date.getDay</li><li>Date.@@toPrimitive</li></ol><h1 id="Float32Array"><a href="#Float32Array" class="headerlink" title="Float32Array"></a>Float32Array</h1><ol><li>Float32Array.from</li><li>Float32Array.of</li><li>Float32Array.copyWithin</li><li>Float32Array.entries</li><li>Float32Array.every</li><li>Float32Array.fill</li><li>Float32Array.filter</li><li>Float32Array.find</li><li>Float32Array.findIndex</li><li>Float32Array.forEach</li><li>Float32Array.indexOf</li><li>Float32Array.join</li><li>Float32Array.keys</li><li>Float32Array.lastIndexOf</li><li>Float32Array.map</li><li>Float32Array.reduce</li><li>Float32Array.reduceRight</li><li>Float32Array.reverse</li><li>Float32Array.set</li><li>Float32Array.slice</li><li>Float32Array.some</li><li>Float32Array.sort</li><li>Float32Array.subarray</li><li>Float32Array.toLocaleString</li><li>Float32Array.toString</li><li>Float32Array.values</li><li>Float32Array.@@iterator</li></ol><h1 id="Float64Array"><a href="#Float64Array" class="headerlink" title="Float64Array"></a>Float64Array</h1><ol><li>Float64Array.from</li><li>Float64Array.of</li><li>Float64Array.copyWithin</li><li>Float64Array.entries</li><li>Float64Array.every</li><li>Float64Array.fill</li><li>Float64Array.filter</li><li>Float64Array.find</li><li>Float64Array.findIndex</li><li>Float64Array.forEach</li><li>Float64Array.indexOf</li><li>Float64Array.join</li><li>Float64Array.keys</li><li>Float64Array.lastIndexOf</li><li>Float64Array.map</li><li>Float64Array.reduce</li><li>Float64Array.reduceRight</li><li>Float64Array.reverse</li><li>Float64Array.set</li><li>Float64Array.slice</li><li>Float64Array.some</li><li>Float64Array.sort</li><li>Float64Array.subarray</li><li>Float64Array.toLocaleString</li><li>Float64Array.toString</li><li>Float64Array.values</li><li>Float64Array.@@iterator</li></ol><h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><ol><li>Generator.next</li><li>Generator.return</li><li>Generator.throw</li></ol><h1 id="Int16Array"><a href="#Int16Array" class="headerlink" title="Int16Array"></a>Int16Array</h1><ol><li>Int16Array.from</li><li>Int16Array.of</li><li>Int16Array.copyWithin</li><li>Int16Array.entries</li><li>Int16Array.every</li><li>Int16Array.fill</li><li>Int16Array.filter</li><li>Int16Array.find</li><li>Int16Array.findIndex</li><li>Int16Array.forEach</li><li>Int16Array.indexOf</li><li>Int16Array.join</li><li>Int16Array.keys</li><li>Int16Array.lastIndexOf</li><li>Int16Array.map</li><li>Int16Array.reduce</li><li>Int16Array.reduceRight</li><li>Int16Array.reverse</li><li>Int16Array.set</li><li>Int16Array.slice</li><li>Int16Array.some</li><li>Int16Array.sort</li><li>Int16Array.subarray</li><li>Int16Array.toLocaleString</li><li>Int16Array.toString</li><li>Int16Array.values</li><li>Int16Array.@@iterator</li></ol><h1 id="Int32Array"><a href="#Int32Array" class="headerlink" title="Int32Array"></a>Int32Array</h1><ol><li>Int32Array.from</li><li>Int32Array.of</li><li>Int32Array.copyWithin</li><li>Int32Array.entries</li><li>Int32Array.every</li><li>Int32Array.fill</li><li>Int32Array.filter</li><li>Int32Array.find</li><li>Int32Array.findIndex</li><li>Int32Array.forEach</li><li>Int32Array.indexOf</li><li>Int32Array.join</li><li>Int32Array.keys</li><li>Int32Array.lastIndexOf</li><li>Int32Array.map</li><li>Int32Array.reduce</li><li>Int32Array.reduceRight</li><li>Int32Array.reverse</li><li>Int32Array.set</li><li>Int32Array.slice</li><li>Int32Array.some</li><li>Int32Array.sort</li><li>Int32Array.subarray</li><li>Int32Array.toLocaleString</li><li>Int32Array.toString</li><li>Int32Array.values</li><li>Int32Array.@@iterator</li></ol><h1 id="Int8Array"><a href="#Int8Array" class="headerlink" title="Int8Array"></a>Int8Array</h1><ol><li>Int8Array.from</li><li>Int8Array.of</li><li>Int8Array.copyWithin</li><li>Int8Array.entries</li><li>Int8Array.every</li><li>Int8Array.fill</li><li>Int8Array.filter</li><li>Int8Array.find</li><li>Int8Array.findIndex</li><li>Int8Array.forEach</li><li>Int8Array.indexOf</li><li>Int8Array.join</li><li>Int8Array.keys</li><li>Int8Array.lastIndexOf</li><li>Int8Array.map</li><li>Int8Array.reduce</li><li>Int8Array.reduceRight</li><li>Int8Array.reverse</li><li>Int8Array.set</li><li>Int8Array.slice</li><li>Int8Array.some</li><li>Int8Array.sort</li><li>Int8Array.subarray</li><li>Int8Array.toLocaleString</li><li>Int8Array.toString</li><li>Int8Array.values</li><li>Int8Array.@@iterator</li></ol><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><ol><li>Map.clear</li><li>Map.delete</li><li>Map.forEach</li><li>Map.get</li><li>Map.has</li><li>Map.keys</li><li>Map.set</li><li>Map.values</li><li>Map.@@iterator</li></ol><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><ol><li>Math.%E5%8F%8D%E5%8F%8C%E6%9B%B2%E4%BD%99%E5%BC%A6%E5%80%BC</li><li>Math.asinh</li><li>Math.atanh</li><li>Math.cbrt</li><li>Math.clz32</li><li>Math.cosh</li><li>Math.expm1</li><li>Math.fround</li><li>Math.hypot</li><li>Math.log10</li><li>Math.log1p</li><li>Math.log2</li><li>Math.sign</li><li>Math.sinh</li><li>Math.tanh</li><li>Math.trunc</li></ol><h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><ol><li>Number.isFinite</li><li>Number.isInteger</li><li>Number.isNaN</li><li>Number.isSafeInteger</li><li>Number.parseFloat</li></ol><h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><ol><li>Object.assign</li><li>Object.getOwnPropertySymbols</li><li>Object.is</li><li>Object.hasOwnProperty</li></ol><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ol><li>Promise.all</li><li>Promise.then</li><li>Promise.race</li><li>Promise.reject</li><li>Promise.resolve</li></ol><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><ol><li>Proxy.apply</li><li>Proxy.construct</li><li>Proxy.defineProperty</li><li>Proxy.deleteProperty</li><li>Proxy.get</li><li>Proxy.getOwnPropertyDescriptor</li><li>Proxy.getPrototypeOf</li><li>Proxy.has</li><li>Proxy.isExtensible</li><li>Proxy.ownKeys</li><li>Proxy.preventExtensions</li><li>Proxy.set</li><li>Proxy.setPrototypeOf</li></ol><h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><ol><li>Reflect.apply</li><li>Reflect.construct</li><li>Reflect.defineProperty</li><li>Reflect.deleteProperty</li><li>Reflect.get</li><li>Reflect.getOwnPropertyDescriptor</li><li>Reflect.getPrototypeOf</li><li>Reflect.has</li><li>Reflect.isExtensible</li><li>Reflect.ownKeys</li><li>Reflect.preventExtensions</li><li>Reflect.set</li><li>Reflect.setPrototypeOf</li></ol><h1 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h1><ol><li>RegExp.compile</li><li>RegExp.@@match</li><li>RegExp.@@replace</li><li>RegExp.@@search</li><li>RegExp.@@split</li></ol><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><ol><li>Set.add</li><li>Set.clear</li><li>Set.delete</li><li>Set.entries</li><li>Set.forEach</li><li>Set.has</li><li>Set.values</li><li>Set.@@iterator</li></ol><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ol><li>String.fromCodePoint</li><li>String.anchor</li><li>String.big</li><li>String.blink</li><li>String.bold</li><li>String.codePointAt</li><li>String.endsWith</li><li>String.fixed</li><li>String.fontcolor</li><li>String.fontsize</li><li>String.italics</li><li>String.link</li><li>String.repeat</li><li>String.slice</li><li>String.small</li><li>String.startsWith</li><li>String.strike</li><li>String.sub</li><li>String.sup</li><li>String.raw</li></ol><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><ol><li>Symbol.for</li><li>Symbol.keyFor</li><li>Symbol.toString</li><li>Symbol.valueOf</li><li>Symbol.@@toPrimitive</li></ol><h1 id="TypedArray"><a href="#TypedArray" class="headerlink" title="TypedArray"></a>TypedArray</h1><ol><li>TypedArray.from</li><li>TypedArray.of</li><li>TypedArray.copyWithin</li><li>TypedArray.entries</li><li>TypedArray.every</li><li>TypedArray.fill</li><li>TypedArray.filter</li><li>TypedArray.find</li><li>TypedArray.findIndex</li><li>TypedArray.forEach</li><li>TypedArray.indexOf</li><li>TypedArray.join</li><li>TypedArray.keys</li><li>TypedArray.lastIndexOf</li><li>TypedArray.map</li><li>TypedArray.reduce</li><li>TypedArray.reduceRight</li><li>TypedArray.reverse</li><li>TypedArray.set</li><li>TypedArray.slice</li><li>TypedArray.some</li><li>TypedArray.sort</li><li>TypedArray.subarray</li><li>TypedArray.toLocaleString</li><li>TypedArray.toString</li><li>TypedArray.values</li><li>TypedArray.@@iterator</li></ol><h1 id="Uint16Array"><a href="#Uint16Array" class="headerlink" title="Uint16Array"></a>Uint16Array</h1><ol><li>Uint16Array.from</li><li>Uint16Array.of</li><li>Uint16Array.copyWithin</li><li>Uint16Array.entries</li><li>Uint16Array.every</li><li>Uint16Array.fill</li><li>Uint16Array.filter</li><li>Uint16Array.find</li><li>Uint16Array.findIndex</li><li>Uint16Array.forEach</li><li>Uint16Array.indexOf</li><li>Uint16Array.join</li><li>Uint16Array.keys</li><li>Uint16Array.lastIndexOf</li><li>Uint16Array.map</li><li>Uint16Array.reduce</li><li>Uint16Array.reduceRight</li><li>Uint16Array.reverse</li><li>Uint16Array.set</li><li>Uint16Array.slice</li><li>Uint16Array.some</li><li>Uint16Array.sort</li><li>Uint16Array.subarray</li><li>Uint16Array.toLocaleString</li><li>Uint16Array.toString</li><li>Uint16Array.values</li><li>Uint16Array.@@iterator</li></ol><h1 id="Uint32Array"><a href="#Uint32Array" class="headerlink" title="Uint32Array"></a>Uint32Array</h1><ol><li>Uint32Array.from</li><li>Uint32Array.of</li><li>Uint32Array.copyWithin</li><li>Uint32Array.entries</li><li>Uint32Array.every</li><li>Uint32Array.fill</li><li>Uint32Array.filter</li><li>Uint32Array.find</li><li>Uint32Array.findIndex</li><li>Uint32Array.forEach</li><li>Uint32Array.indexOf</li><li>Uint32Array.join</li><li>Uint32Array.keys</li><li>Uint32Array.lastIndexOf</li><li>Uint32Array.map</li><li>Uint32Array.reduce</li><li>Uint32Array.reduceRight</li><li>Uint32Array.reverse</li><li>Uint32Array.set</li><li>Uint32Array.slice</li><li>Uint32Array.some</li><li>Uint32Array.sort</li><li>Uint32Array.subarray</li><li>Uint32Array.toLocaleString</li><li>Uint32Array.toString</li><li>Uint32Array.values</li><li>Uint32Array.@@iterator</li></ol><h1 id="Uint8Array"><a href="#Uint8Array" class="headerlink" title="Uint8Array"></a>Uint8Array</h1><ol><li>Uint8Array.from</li><li>Uint8Array.of</li><li>Uint8Array.copyWithin</li><li>Uint8Array.entries</li><li>Uint8Array.every</li><li>Uint8Array.fill</li><li>Uint8Array.filter</li><li>Uint8Array.find</li><li>Uint8Array.findIndex</li><li>Uint8Array.forEach</li><li>Uint8Array.indexOf</li><li>Uint8Array.join</li><li>Uint8Array.keys</li><li>Uint8Array.lastIndexOf</li><li>Uint8Array.map</li><li>Uint8Array.reduce</li><li>Uint8Array.reduceRight</li><li>Uint8Array.reverse</li><li>Uint8Array.set</li><li>Uint8Array.slice</li><li>Uint8Array.some</li><li>Uint8Array.sort</li><li>Uint8Array.subarray</li><li>Uint8Array.toLocaleString</li><li>Uint8Array.toString</li><li>Uint8Array.values</li><li>Uint8Array.@@iterator</li></ol><h1 id="Uint8ClampedArray"><a href="#Uint8ClampedArray" class="headerlink" title="Uint8ClampedArray"></a>Uint8ClampedArray</h1><ol><li>Uint8ClampedArray.from</li><li>Uint8ClampedArray.of</li><li>Uint8ClampedArray.copyWithin</li><li>Uint8ClampedArray.entries</li><li>Uint8ClampedArray.every</li><li>Uint8ClampedArray.fill</li><li>Uint8ClampedArray.filter</li><li>Uint8ClampedArray.find</li><li>Uint8ClampedArray.findIndex</li><li>Uint8ClampedArray.forEach</li><li>Uint8ClampedArray.indexOf</li><li>Uint8ClampedArray.join</li><li>Uint8ClampedArray.keys</li><li>Uint8ClampedArray.lastIndexOf</li><li>Uint8ClampedArray.map</li><li>Uint8ClampedArray.reduce</li><li>Uint8ClampedArray.reduceRight</li><li>Uint8ClampedArray.reverse</li><li>Uint8ClampedArray.set</li><li>Uint8ClampedArray.slice</li><li>Uint8ClampedArray.some</li><li>Uint8ClampedArray.sort</li><li>Uint8ClampedArray.subarray</li><li>Uint8ClampedArray.toLocaleString</li><li>Uint8ClampedArray.toString</li><li>Uint8ClampedArray.values</li><li>Uint8ClampedArray.@@iterator</li></ol><h1 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h1><ol><li>WeakMap.delete</li><li>WeakMap.get</li><li>WeakMap.has</li><li>WeakMap.set</li></ol><h1 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h1><ol><li>WeakSet.add</li><li>WeakSet.delete</li><li>WeakSet.has</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> ES版本 </tag>
            
            <tag> ES2015 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript版本拾荒记——ES2020</title>
      <link href="/2019/12/30/JavaScript%E7%89%88%E6%9C%AC%E6%8B%BE%E8%8D%92%E8%AE%B0%E2%80%94%E2%80%94ES2020/"/>
      <url>/2019/12/30/JavaScript%E7%89%88%E6%9C%AC%E6%8B%BE%E8%8D%92%E8%AE%B0%E2%80%94%E2%80%94ES2020/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> ES版本 </tag>
            
            <tag> ES2020 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript版本拾荒记——ES2019</title>
      <link href="/2019/12/30/JavaScript%E7%89%88%E6%9C%AC%E6%8B%BE%E8%8D%92%E8%AE%B0%E2%80%94%E2%80%94ES2019/"/>
      <url>/2019/12/30/JavaScript%E7%89%88%E6%9C%AC%E6%8B%BE%E8%8D%92%E8%AE%B0%E2%80%94%E2%80%94ES2019/</url>
      
        <content type="html"><![CDATA[<h3 id="Array-prototype-flat-Array-prototype-flatMap"><a href="#Array-prototype-flat-Array-prototype-flatMap" class="headerlink" title="Array.prototype.flat()/ Array.prototype.flatMap()"></a>Array.prototype.flat()/ Array.prototype.flatMap()</h3><h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h3><h3 id="String-prototype-trimStart-trimEnd"><a href="#String-prototype-trimStart-trimEnd" class="headerlink" title="String.prototype.trimStart() / .trimEnd()"></a>String.prototype.trimStart() / .trimEnd()</h3><h3 id="Optional-Catch-Binding"><a href="#Optional-Catch-Binding" class="headerlink" title="Optional Catch Binding"></a>Optional Catch Binding</h3><h3 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString()"></a>Function.prototype.toString()</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> ES版本 </tag>
            
            <tag> ES2019 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript版本拾荒记——ES2018</title>
      <link href="/2019/12/30/JavaScript%E7%89%88%E6%9C%AC%E6%8B%BE%E8%8D%92%E8%AE%B0%E2%80%94%E2%80%94ES2018/"/>
      <url>/2019/12/30/JavaScript%E7%89%88%E6%9C%AC%E6%8B%BE%E8%8D%92%E8%AE%B0%E2%80%94%E2%80%94ES2018/</url>
      
        <content type="html"><![CDATA[<h3 id="对象Rest-Spread-ES5数组解构"><a href="#对象Rest-Spread-ES5数组解构" class="headerlink" title="对象Rest / Spread (ES5数组解构)"></a>对象Rest / Spread (ES5数组解构)</h3><h3 id="Asynchronous-Iteration（for…await）"><a href="#Asynchronous-Iteration（for…await）" class="headerlink" title="Asynchronous Iteration（for…await）"></a>Asynchronous Iteration（for…await）</h3><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> ES版本 </tag>
            
            <tag> ES2018 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript版本拾荒记——ES2017</title>
      <link href="/2019/12/30/JavaScript%E7%89%88%E6%9C%AC%E6%8B%BE%E8%8D%92%E8%AE%B0%E2%80%94%E2%80%94ES2017/"/>
      <url>/2019/12/30/JavaScript%E7%89%88%E6%9C%AC%E6%8B%BE%E8%8D%92%E8%AE%B0%E2%80%94%E2%80%94ES2017/</url>
      
        <content type="html"><![CDATA[<h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><pre><code>1. String.padEnd2. String.padStart</code></pre><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><pre><code>1. Object.entries2. Object.getOwnPropertyDescriptors3. Object.values</code></pre><h3 id="async-awiat"><a href="#async-awiat" class="headerlink" title="async/awiat"></a>async/awiat</h3><h1 id="全部"><a href="#全部" class="headerlink" title="全部"></a>全部</h1><h1 id="Object-1"><a href="#Object-1" class="headerlink" title="Object"></a>Object</h1><ol><li>Object.entries</li><li>Object.getOwnPropertyDescriptors</li><li>Object.values</li></ol><h1 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h1><ol><li>String.padEnd</li><li>String.padStart</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> ES版本 </tag>
            
            <tag> ES2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript版本拾荒记——ES2016</title>
      <link href="/2019/12/30/JavaScript%E7%89%88%E6%9C%AC%E6%8B%BE%E8%8D%92%E8%AE%B0%E2%80%94%E2%80%94ES2016/"/>
      <url>/2019/12/30/JavaScript%E7%89%88%E6%9C%AC%E6%8B%BE%E8%8D%92%E8%AE%B0%E2%80%94%E2%80%94ES2016/</url>
      
        <content type="html"><![CDATA[<h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><ul><li>Array.prototype.includes()</li></ul><ul><li><p>指数操作符(**)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">4</span>) === <span class="number">2</span> ** <span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="全部"><a href="#全部" class="headerlink" title="全部"></a>全部</h1><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><ol><li>Array.includes</li></ol><h1 id="BigUint64Array"><a href="#BigUint64Array" class="headerlink" title="BigUint64Array"></a>BigUint64Array</h1><ol><li>BigUint64Array.includes</li></ol><h1 id="Float32Array"><a href="#Float32Array" class="headerlink" title="Float32Array"></a>Float32Array</h1><ol><li>Float32Array.includes</li></ol><h1 id="Float64Array"><a href="#Float64Array" class="headerlink" title="Float64Array"></a>Float64Array</h1><ol><li>Float64Array.includes</li></ol><h1 id="Int16Array"><a href="#Int16Array" class="headerlink" title="Int16Array"></a>Int16Array</h1><ol><li>Int16Array.includes</li></ol><h1 id="Int32Array"><a href="#Int32Array" class="headerlink" title="Int32Array"></a>Int32Array</h1><ol><li>Int32Array.includes</li></ol><h1 id="Int8Array"><a href="#Int8Array" class="headerlink" title="Int8Array"></a>Int8Array</h1><ol><li>Int8Array.includes</li></ol><h1 id="TypedArray"><a href="#TypedArray" class="headerlink" title="TypedArray"></a>TypedArray</h1><ol><li>TypedArray.includes</li></ol><h1 id="Uint16Array"><a href="#Uint16Array" class="headerlink" title="Uint16Array"></a>Uint16Array</h1><ol><li>Uint16Array.includes</li></ol><h1 id="Uint32Array"><a href="#Uint32Array" class="headerlink" title="Uint32Array"></a>Uint32Array</h1><ol><li>Uint32Array.includes</li></ol><h1 id="Uint8Array"><a href="#Uint8Array" class="headerlink" title="Uint8Array"></a>Uint8Array</h1><ol><li>Uint8Array.includes</li></ol><h1 id="Uint8ClampedArray"><a href="#Uint8ClampedArray" class="headerlink" title="Uint8ClampedArray"></a>Uint8ClampedArray</h1><ol><li>Uint8ClampedArray.includes</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> ES版本 </tag>
            
            <tag> ES2016 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一周总结（2019-12-23~2019-12-29）</title>
      <link href="/2019/12/29/%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%882019-12-23-2019-12-29%EF%BC%89/"/>
      <url>/2019/12/29/%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%882019-12-23-2019-12-29%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="主线任务"><a href="#主线任务" class="headerlink" title="主线任务"></a>主线任务</h3><ol><li><p>将<a href="/tags/ES版本/">ES版本解读</a>替换为<a href="/tags/正则表达式/">正则表达式</a>（本周练习频率：每天）</p><p>目前对于正则表达式的了解程度已经足够，之后做周期性练习即可（每周）</p></li><li><p><a href="/tags/Vim">Vim</a>（本周练习频率：每天）</p><p>本周对Vim也做了大量的练习，记录了一些常用的键位及练习方式，之后也会做周期性练习（每周）</p></li><li><p><a href="/tags/VScode">VScode</a></p><p>利用闲暇时间对编辑器常用功能做了整理，因为是日用软件，所以不必刻意练习</p></li><li><p><a href="/tags/Terminal">Terminal</a></p><p>记录了一些常用快捷键，也是日用频率吧，不必刻意练习</p></li></ol><h3 id="副本剧情"><a href="#副本剧情" class="headerlink" title="副本剧情"></a>副本剧情</h3><ol><li>leetcode刷题：数组刷完了，字符串也刷了一部分</li><li>git高级操作：<a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">https://learngitbranching.js.org/</a></li><li><a href="/tags/GraphQL">GraphQL</a>：对GraphQL做了一些简单的了解，后续有时间会进一步了解</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 一周总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter环境搭建</title>
      <link href="/2019/12/28/Flutter%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/12/28/Flutter%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="一、基础资源设置-下载"><a href="#一、基础资源设置-下载" class="headerlink" title="一、基础资源设置 + 下载"></a>一、基础资源设置 + 下载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 设置国内镜像</span><br><span class="line">vi ~/.zshrc</span><br><span class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br><span class="line">source .zshrc</span><br><span class="line"></span><br><span class="line">// 下载flutter sdk</span><br><span class="line">cd ~/Desktop/github</span><br><span class="line">git clone https://github.com/flutter/flutter.git</span><br><span class="line"></span><br><span class="line">// 设置flutter环境变量</span><br><span class="line">vi ~/.zshrc</span><br><span class="line">export PATH="$PATH:~/desktop/github/flutter/bin"</span><br><span class="line">source .zshrc</span><br></pre></td></tr></table></figure><h3 id="二、基础环境"><a href="#二、基础环境" class="headerlink" title="二、基础环境"></a>二、基础环境</h3><ol><li>安装Xcode、IOS模拟器、Android Studio</li><li>执行flutter doctor命令，这里还是要挂VPN（要不就卡在build flutter tool…）</li><li>根据第<strong>2</strong>执行的结果有啥毛病按提示解决掉</li></ol><h3 id="三、编辑器设置（VSCode）"><a href="#三、编辑器设置（VSCode）" class="headerlink" title="三、编辑器设置（VSCode）"></a>三、编辑器设置（VSCode）</h3><ol><li>安装flutter扩展程序</li><li>设置flutter扩展程序的flutter sdk path</li><li>cmd + shift + p: flutter: 创建新项目</li><li>启动IOS模拟器</li><li>按下F5</li></ol><p><img alt="完美" data-src="/images/2019-12-29_00-04-01.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 移动端APP </tag>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每月总结（2019-12）</title>
      <link href="/2019/12/28/%E6%AF%8F%E6%9C%88%E6%80%BB%E7%BB%93%EF%BC%882019-12%EF%BC%89/"/>
      <url>/2019/12/28/%E6%AF%8F%E6%9C%88%E6%80%BB%E7%BB%93%EF%BC%882019-12%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>11月份离职，本来想休息个两个月，一边放松一边准备面试工作，但待了一个月感觉特备无聊。于是12月份开始认真投简历找工作了。这个月前半个月基本都在面试了，第一周每天面试两场，然而不是我觉得对方不合适就是对方觉得我不合适，当然每一份简历我都投的很认真的。</p><h3 id="面试感悟"><a href="#面试感悟" class="headerlink" title="面试感悟"></a>面试感悟</h3><p>大家都说今年工作更难找了，我觉得也就那样吧。主要是人太多了吧（各种培训机构，不像传统的学校，技术更新更具时效性），还有就是互联网也不像以前那样烧钱了，很多小公司都坚持不下去了，连大厂都开始裁员过冬了。总之就是狼多肉少了，经验丰富的老手也开始从大厂撤离跟小散抢肉吃了。面试下来，就感觉我这个水平，基本是处于一个大众水平，两年经验，其他优势完全不能在面试的时候显现出来，比如学习能力，专注性（因为太过容易专注于当前所做的事情，所以反而这个在面试时成了一个非常大的劣势）。</p><h3 id="是时候选择了"><a href="#是时候选择了" class="headerlink" title="是时候选择了"></a>是时候选择了</h3><p>摆在我面前的有两个选择：一是去小厂当leader，二是去大厂外包。如果选择一的话，我肯定还会像以前一样去做同样的事情，基于现在的技术栈，去实现业务功能，其实就是躺在舒适区做重复的事情而已，还有考虑到未来稳定性，因为自己对未来一段时间的考虑还不是特别明确，所以也要选择相对不太稳定的工作（如果去小厂搞搞然后不搞跑路也太不负责了）。去外包的话，网上有很多负面评论，不过不去试试又怎能知道真实情况呢。还有就是这种基于外派的形式，多多少少可以了解到一些大厂的氛围、处事手段、新的架构模式等。还有就是看到比自己更厉害的人，就拥有了很强烈的要超越的心，可以一直督促自己。</p><h3 id="两周经验"><a href="#两周经验" class="headerlink" title="两周经验"></a>两周经验</h3><p>前半月找工作，后半月投入工作。公司待了两周多，除了权限、装备差些，其他都还行。公司也是有一套固有前端架构，但架构的基础技术，都是我很熟悉的，很快就上手了。然后，平时做的事情也就是具体的某个业务模块，平时用到的一些工具虽然有些不一样，但和以前常用的工具也大都类似，如编辑器、代理工具等。</p><h3 id="我做了哪些决定"><a href="#我做了哪些决定" class="headerlink" title="我做了哪些决定"></a>我做了哪些决定</h3><p>其实从去年开始，我就感觉自己遇到了技术瓶颈，不知道该如何去突破。所以经常会去尝试其他边缘技术，而不是再去深度挖掘前端核心技术。比如去玩PS、写个Unity3D、耍耍Three.js，然后再去研究股票，读些乱七八糟的书。最后觉得都很无聊的时候，再去看看《大话计算机》、《大话设计模式》等。</p><p>最近的核心放在了一些更加基础的工具上，比如git、vim、vscode等，不断熟练快捷键，接下来的核心会集中在NodeJS、React、CSS、JavaScript的深度解读上。除了广度到深度的转变之外，还有以下重要决定：</p><ol><li>资讯收集</li><li>日常基础训练</li><li>固定周期总结</li><li>认知三部曲：背景（为什么）、如何解决（技术方案）、实现（产品）、扩展（二次封装）</li></ol><h3 id="这个月我学到了什么？"><a href="#这个月我学到了什么？" class="headerlink" title="这个月我学到了什么？"></a>这个月我学到了什么？</h3><ol><li>Terminal的一些常用快捷键</li><li>打造适合自己的VSCode</li><li>熟悉Vim</li><li>熟悉正则表达式</li><li>Leetcode刷题(数组 + 字符串)</li><li>ES版本拾荒(ES6)</li><li>重新认识Babel</li><li>React 15拾荒</li><li>markdown复习(因为要经常使用markdown写博客)</li><li>如何对webpack进行优化</li><li>React脚手架(yume-ywc)：目前看来，这个模板不是特别优秀，当是练习yeoman好了</li></ol><blockquote><p>后来才发现：只要不在意结果，那一切就都有了答案。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 每月总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一周资讯总结（2019-12-23~2019-23-29）</title>
      <link href="/2019/12/28/%E4%B8%80%E5%91%A8%E8%B5%84%E8%AE%AF%E6%80%BB%E7%BB%93%EF%BC%882019-12-23-2019-23-29%EF%BC%89/"/>
      <url>/2019/12/28/%E4%B8%80%E5%91%A8%E8%B5%84%E8%AE%AF%E6%80%BB%E7%BB%93%EF%BC%882019-12-23-2019-23-29%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="（来源）Twitter"><a href="#（来源）Twitter" class="headerlink" title="（来源）Twitter"></a>（来源）Twitter</h3><ol><li>gistpad：<a href="https://marketplace.visualstudio.com/items?itemName=vsls-contrib.gistfs" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=vsls-contrib.gistfs</a></li><li>关于Nodejs的一个微服务架构：<a href="https://github.com/parkroolucas/microservices-demo" target="_blank" rel="noopener">https://github.com/parkroolucas/microservices-demo</a></li><li>又一个类React/Vue框架：<a href="https://svelte.dev/" target="_blank" rel="noopener">https://svelte.dev/</a></li><li>你不知道的强大的consoleAPI：<a href="https://dev.to/karkranikhil/javascript-developer-must-know-these-console-methods-57oa" target="_blank" rel="noopener">https://dev.to/karkranikhil/javascript-developer-must-know-these-console-methods-57oa</a></li><li>纯JS实现的OCR库：<a href="https://github.com/naptha/tesseract.js" target="_blank" rel="noopener">https://github.com/naptha/tesseract.js</a></li><li>Facebook大佬的博客：<a href="https://overreacted.io/" target="_blank" rel="noopener">https://overreacted.io/</a></li><li>v8发布新版本：<a href="https://v8.dev/blog/v8-release-80" target="_blank" rel="noopener">https://v8.dev/blog/v8-release-80</a></li><li>如何使用[]()!+六个字符输出self：<a href="https://javascript.christmas/2019/17" target="_blank" rel="noopener">https://javascript.christmas/2019/17</a></li></ol><h3 id="（来源）其他"><a href="#（来源）其他" class="headerlink" title="（来源）其他"></a>（来源）其他</h3><ol><li>web components：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Web_Components</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 一周总结 </tag>
            
            <tag> 资讯总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GraphQL初探</title>
      <link href="/2019/12/28/GraphQL%E5%88%9D%E6%8E%A2/"/>
      <url>/2019/12/28/GraphQL%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="基础库"><a href="#基础库" class="headerlink" title="基础库"></a>基础库</h3><ol><li>graphql</li><li>express-graphql</li><li>apollo-server-express</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> GraphQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Termial快捷键</title>
      <link href="/2019/12/28/Termial%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/12/28/Termial%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><ol><li>ctrl + a/e：到头/尾</li><li>ctrl + u/k：剪切光标前/后 所有单词</li><li>ctrl + y：撤销上个操作</li><li>ctrl + w：删除光标前一个单词</li><li>ctrl + r: 搜索历史记录</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
            <tag> Terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于VSCode</title>
      <link href="/2019/12/27/%E5%85%B3%E4%BA%8EVSCode/"/>
      <url>/2019/12/27/%E5%85%B3%E4%BA%8EVSCode/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本人Webstorm党，特别依赖它集成的git工具，觉得特别好用。以前也因为团队用的是SourceTree + VSCode，有一段时间去尝试适应，但SourceTree真的太丑了，VSCode主题真的太丑了（到现在我都还没有找到一款很合我口味的亮色主题），就像Sublime Text一样。但WebStorm很吃内存，项目第一次加载时特别慢，不过这都不是问题，关键是要收费（怪不得做的这么好）。所以也一直想往VSCode方向转，这次换工作后也是一个契机吧，刚好git也要用原始的命令号来搞了（非要把逼格搞上去不可），VSCode做merge的时候两个窗口的比较也没以前那么差劲了。所以VSCode就好好学下吧。</p><h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><ol><li>主题：FlatUI Immersed</li><li>tab缩进设置：2|4</li><li>快捷键设置<ul><li>ctrl + u：转换为小写</li><li>ctrl + shift + u：转换为大写</li></ul></li><li>设置PanelDefault Location位置为right</li><li>cmd + shift + p =&gt; shell（在path中安装code命令），可以在终端使用code命令打开编辑器</li><li>List: Open Mode设置双击点开文件夹</li></ol><h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><ol><li>Auto Close Tag</li><li>Todo Tree</li><li>FlatUI</li><li>Reactjs code snippets</li><li>vscode-icons</li><li>settings sync（牛逼，写好一份配置）</li></ol><h3 id="自定义代码片段-cmd-shift-p-gt-snippets"><a href="#自定义代码片段-cmd-shift-p-gt-snippets" class="headerlink" title="自定义代码片段(cmd + shift + p =&gt; snippets)"></a>自定义代码片段(cmd + shift + p =&gt; snippets)</h3><ol><li><p>cl</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log($<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>cld</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`-----  start  -----`</span>);</span><br><span class="line"><span class="built_in">console</span>.log($<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`-----  end  -----`</span>);</span><br></pre></td></tr></table></figure></li><li><p>author</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* author: iWuzhi</span></span><br><span class="line"><span class="comment">* date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>option + shfit + ↑/↓</td><td>向上/下复制一行</td></tr><tr><td>option + ↑/↓</td><td>向上/下移动</td></tr><tr><td>cmd + shift + p</td><td>全局命令面板</td></tr><tr><td>cmd + shift + n</td><td>新窗口</td></tr><tr><td>cmd + shift + w</td><td>关闭编辑器</td></tr><tr><td>cmd + w</td><td>关闭当前tab</td></tr><tr><td>cmd + shift + k</td><td>删除当前行</td></tr><tr><td>cmd + enter</td><td>下一行插入</td></tr><tr><td>cmd + shift + enter</td><td>上一行插入</td></tr><tr><td>cmd + shift + |</td><td>花括号闭合处跳转</td></tr><tr><td>cmd + []</td><td>调整缩进</td></tr><tr><td>cmd + shift + []</td><td>窗口tab切换</td></tr><tr><td>options + shift + a</td><td>区块注释</td></tr><tr><td>ctrl + g</td><td>行跳转</td></tr><tr><td>cmd + k, cmd + s</td><td>快捷键绑定/查询</td></tr><tr><td>ctrl + `</td><td>打开终端</td></tr><tr><td>cmd + shift + t</td><td>撤销最近关闭的一个tab</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>能想到一些就写一些吧，^_^</p>]]></content>
      
      
      
        <tags>
            
            <tag> VSCode </tag>
            
            <tag> 编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Vim</title>
      <link href="/2019/12/27/%E5%85%B3%E4%BA%8EVim/"/>
      <url>/2019/12/27/%E5%85%B3%E4%BA%8EVim/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Vim？"><a href="#什么是Vim？" class="headerlink" title="什么是Vim？"></a>什么是Vim？</h3><p>Vim是一个基于(命令行式)终端的文本编辑器，最大特点就是所有操作都是使用键盘操作而非鼠标，所以盛行于各种服务器，其背景也是因为服务器端缺乏优秀的文本编辑器。</p><h3 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h3><p>Vim有两种模式：</p><ol><li>插入模式(i)：这时和一个普通的文本编辑器基本没啥差别，你可以使用正常键位进行任意文本输入</li><li>正常模式(Esc)：这时更多的是充当一个文本阅览功能，你可以使用一些键位组合快速移动或删除替换一些文本</li></ol><h3 id="基本移动-光标-操作"><a href="#基本移动-光标-操作" class="headerlink" title="基本移动(光标)操作"></a>基本移动(光标)操作</h3><ol><li>h、j、k、l：（左、下、上、右）移动单个字符</li><li>w、e、b（下个单词开始处、单词结尾处、单词开始处）移动整个单词</li><li>数字 + 移动操作(h/j/k/l/w/e/b)：移动基本单元 * 数字，相当于移动多次了</li><li>0/$：移动到行首/尾</li><li>gg/G: 移动到文本开始/结束处</li><li>/：搜索（n：next，N：pre）</li></ol><h3 id="文本编辑（插入-替换-删除）"><a href="#文本编辑（插入-替换-删除）" class="headerlink" title="文本编辑（插入/替换/删除）"></a>文本编辑（插入/替换/删除）</h3><ol><li>o：在下一行插入（进入插入模式）</li><li>x:  删除当前字符</li><li>r:  替换当前字符</li><li>d: 删除指定字符<ul><li>d: 删除整行</li><li>$: 删除光标之后</li><li>0: 删除光标之前的</li><li>w: 下一个单词开始之前</li><li>e: 当前单词结尾</li><li>b: 当前单词开始</li><li>h/j/k/l: 光标到移动的位置</li><li>n[movement]: 移动n次的位置</li></ul></li><li>a: 在当前行之后插入</li><li>D: 删除行剩余部分</li><li>S: 删除当前行并进入insert模式</li><li>yy: 复制当前行</li><li>p:  粘贴复制的文本<h3 id="常用链接"><a href="#常用链接" class="headerlink" title="常用链接"></a>常用链接</h3></li></ol><ul><li><a href="https://www.openvim.com/sandbox.html" target="_blank" rel="noopener">https://www.openvim.com/sandbox.html</a>   （一个非常棒的在线交互式练习网站）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 编辑器 </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于正则表达式</title>
      <link href="/2019/12/25/%E5%85%B3%E4%BA%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/12/25/%E5%85%B3%E4%BA%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="JavaScript中的正则表达式"><a href="#JavaScript中的正则表达式" class="headerlink" title="JavaScript中的正则表达式"></a>JavaScript中的正则表达式</h3><ol><li>RegExp.exex/test</li><li>String.match/matchAll/replace/search/split</li></ol><h3 id="创建一个正则表达式"><a href="#创建一个正则表达式" class="headerlink" title="创建一个正则表达式"></a>创建一个正则表达式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量：脚本加载后编译，更好的性能</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/ab+c/</span>;</span><br><span class="line"><span class="comment">// 构造函数：运行时编译，动态构造表达式，更加灵活</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ab+c'</span>);</span><br></pre></td></tr></table></figure><h3 id="正则表达式特殊字符含义"><a href="#正则表达式特殊字符含义" class="headerlink" title="正则表达式特殊字符含义"></a>正则表达式特殊字符含义</h3><h5 id="字符类别"><a href="#字符类别" class="headerlink" title="字符类别"></a>字符类别</h5><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>匹配任意单个字符，但是行结束符除外：<code>\n</code> <code>\r</code> <code>\u2028</code> 或 <code>\u2029</code>。</td></tr><tr><td>\d</td><td>[0-9]</td></tr><tr><td>\D</td><td>[^0-9]</td></tr><tr><td>\w</td><td>[A-Za-z0-9_]</td></tr><tr><td>\W</td><td>[^A-Za-z0-9]</td></tr><tr><td>\s</td><td>匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格</td></tr><tr><td>\S</td><td>匹配一个非空白符（注意和”.”的区别）</td></tr><tr><td>\t</td><td>水平制表符Tab</td></tr><tr><td>\r</td><td>回车符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>[\b]</td><td>退格符</td></tr><tr><td>\0</td><td>NUL字符</td></tr><tr><td>\cX</td><td><code>X</code> 是 A - Z 的一个字母。匹配字符串中的一个控制字符。</td></tr><tr><td>\xhh</td><td>匹配编码为 <code>hh</code> （两个十六进制数字）的字符。</td></tr><tr><td>\uhhh</td><td>匹配 Unicode 值为 <code>hhhh</code> （四个十六进制数字）的字符。</td></tr><tr><td>\</td><td>转义字符</td></tr></tbody></table><h5 id="字符集合"><a href="#字符集合" class="headerlink" title="字符集合"></a>字符集合</h5><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>[xyz]</td><td>匹配集合中的任意一个字符。你可以使用连字符’-‘指定一个范围。</td></tr><tr><td>[^xyz]</td><td>任意不在括号内的字符</td></tr></tbody></table><h5 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h5><table><thead><tr><th>字符</th><th>含</th></tr></thead><tbody><tr><td>^</td><td>匹配输入开始。</td></tr><tr><td><code>$</code></td><td>匹配输入结尾。</td></tr><tr><td>\b</td><td>匹配一个零宽单词边界，如一个字母与一个空格之间。</td></tr><tr><td>\B</td><td>匹配一个零宽非单词边界，如两个字母之间或两个空格之间</td></tr></tbody></table><h5 id="分组与反向引用"><a href="#分组与反向引用" class="headerlink" title="分组与反向引用"></a>分组与反向引用</h5><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>(x)</td><td>匹配 <code>x</code> 并且捕获匹配项。 这被称为捕获括号（capturing parentheses）。</td></tr><tr><td>\n</td><td><code>n</code> 是一个正整数。一个反向引用（back reference），指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串。</td></tr><tr><td>(?:x)</td><td>匹配 <code>x</code> 不会捕获匹配项。</td></tr></tbody></table><h5 id="数量词"><a href="#数量词" class="headerlink" title="数量词"></a>数量词</h5><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>x*</td><td>匹配前面的模式x0次或多次</td></tr><tr><td>x+</td><td>匹配前面的模式x1次或多次</td></tr><tr><td>x*?<br>x+?</td><td>像上面的 * 和 + 一样匹配前面的模式 <em>x</em>，然而匹配是最小可能匹配</td></tr><tr><td>x?</td><td>匹配前面的模式x0或1次</td></tr><tr><td>x|y</td><td>匹配x或y</td></tr><tr><td>x{n}</td><td>前面的模式 <em>x</em> 连续出现 n 次时匹配</td></tr><tr><td>x{n,}</td><td>前面的模式 <em>x</em> 连续出现至少 n 次时匹配</td></tr><tr><td>x{n, m}</td><td>前面的模式 x 连续出现至少 n 次，至多 m 次时匹配</td></tr></tbody></table><h5 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h5><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>x(?=y)</td><td>仅匹配被y跟随的x</td></tr><tr><td>x(?!y)</td><td>仅匹配不被y跟随的x</td></tr><tr><td>(?&lt;=y)x</td><td>x只有在y后面才匹配</td></tr><tr><td>(?&lt;=!y)x</td><td>x只有不在y后面才匹配</td></tr></tbody></table><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>MDN: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes</a><br>RegexGolf: <a href="https://alf.nu/RegexGolf#accesstoken=YizTpRHBDopcV+NlVPe8" target="_blank" rel="noopener">https://alf.nu/RegexGolf#accesstoken=YizTpRHBDopcV+NlVPe8</a><br>common-regex: <a href="https://github.com/cdoco/common-regex" target="_blank" rel="noopener">https://github.com/cdoco/common-regex</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>任重而道远，每周安排任务慢慢练习吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12306自动购票程序（方案记录）</title>
      <link href="/2019/12/22/12306%E8%87%AA%E5%8A%A8%E8%B4%AD%E7%A5%A8%E7%A8%8B%E5%BA%8F%EF%BC%88%E6%96%B9%E6%A1%88%E8%AE%B0%E5%BD%95%EF%BC%89/"/>
      <url>/2019/12/22/12306%E8%87%AA%E5%8A%A8%E8%B4%AD%E7%A5%A8%E7%A8%8B%E5%BA%8F%EF%BC%88%E6%96%B9%E6%A1%88%E8%AE%B0%E5%BD%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>时间有点赶，先简单记下好了：</p><p><img alt="思路" data-src="/images/2019-12-22_22-26-21.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 日常工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一周总结（2019.12.16-2019.12.22）</title>
      <link href="/2019/12/22/%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%882019-12-16-2019-12-22%EF%BC%89/"/>
      <url>/2019/12/22/%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%882019-12-16-2019-12-22%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>因为换了新工作，所以这周的主线是适应新环境吧，当然每天副本还是要刷的。</p><p>因为是外包性质，所以关注的工作之外事情可能要比以往更多些，稍微有点烦。入职时除了大厂的流程比较长浪费了比较长的时间，其他都还好。这周对自己的表现，无论是环境适应、新的架构学习还是项目的认知程度，都是比较满意的，总体状态还是很不错。</p><p>虽然就一周时间，但对我个人的认知还是有很大的提升。</p><ol><li>对外包（外派形式）这种模式有了一个更感性的认识，切切实实感受到了这种模式下对于一个雇员的弊端，以及对于金主的一些优势。还有就是雇主的这种经营模式，了解到雇主如何管理这些数量巨大的雇员，以及维系雇主和金主的项目风险问题。</li><li>因为周围都是大佬，虽然做的事情不一样，但从他们的做事风格，说话方式，处理一件事的流程，很容易看到自己的短板。还有就是他们每个人基本都会有一个方向是特别精通，这点我就感觉自己很差，因为以前都没想好方向，平时接触到的东西又太多了，难免分心，而且之前本来就是计划先拓宽自己的技能栈，然后再找到自己想做的事情根据需要去精通。虽然目前还没有一个特别优于别人的优势，但视野总算是没令自己失望。</li><li>“工欲善其事，必先利其器”，可能和我过去的经历有关吧，一度觉得很多工具，像git、vim这种需要命令行的操作可以借助一些可视化工具。当然刚开始学的时候肯定是在终端里去尝试，但平时可能会因为效率问题而使用可视化工具。但在我看到leader一连贯的命令行操作之后，整个人都懵逼了，然后这个思维基本就变过来了，不再纠结效率和逼格的问题了，对于一些常用的工具的命令号操作都会去认认真真的学，而不是简单的尝试。</li><li>还有就是我发现自己获取资讯的来源太少，最近还有用头条（种类太多，不太适合职业资讯）、掘金（有点大水漫灌的感觉现在，含金量不高了）之类的，以前什么都不用的，纯粹感觉自己是封闭了，也许是因为要学的东西比较多吧（Flutter、Three.js、PS…），光看官方的文档就已经够呛的了。今后会对资讯做进一步计划，对需要的资讯来源定期检查（目前考虑可能是一周整理一次）。</li></ol><p>其他大部分工作时间还是和项目有关系，这里就不记录了。</p><p>然后这周的副本：</p><ol><li><p>LeetCode刷题</p><ul><li>进度：初级算法-数组，每天一道题，快刷完了</li><li>成就：做题速度变快了，刷题兴致更高了，对于数组的一些奇葩操作也更熟悉了</li></ul></li><li><p>ES版本解读：这块可能会中间穿插副本剧情，比如优先研究v8版本变化（有官方文档，更靠谱）或熟悉正则表达式，还得看时间再安排下。</p></li></ol><p>总体这周过的还是非常有意义的，处理了很多事情，也想了很多，今后的发展方向、职业目标、个人期望以及生活方式也渐渐开始明朗起来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 一周总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript版本拾荒记——ES6</title>
      <link href="/2019/12/15/JavaScript%E7%89%88%E6%9C%AC%E6%8B%BE%E8%8D%92%E8%AE%B0%E2%80%94%E2%80%94ES6/"/>
      <url>/2019/12/15/JavaScript%E7%89%88%E6%9C%AC%E6%8B%BE%E8%8D%92%E8%AE%B0%E2%80%94%E2%80%94ES6/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前看东西都是杂七杂八的，主要在MDN上看，一般都只会读到最新版的文档，因为有babel这种神器，也不会太去考虑版本兼容的问题，最近发现自己在这方面真的是太弱势了，所以想总结下ES各个版本的变化及差异。查查资料，看看JS的发展史，瞬间就感觉自己是半道（2016年学艺）出家，有太多的空白需要填补。</p><p>目前考虑ES6主线以阮一峰大佬的ES 6入门为主：<a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">https://es6.ruanyifeng.com/</a><br>ES5查漏补缺以网道为主：<a href="https://wangdoc.com/javascript/basic/" target="_blank" rel="noopener">https://wangdoc.com/javascript/basic/</a></p><h3 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h3><ol><li>（不存在）变量提升</li><li>暂时性死区（一定要先声明，后赋值）</li><li>typeof不再100%安全（一定要先声明，后赋值）</li><li>不允许重复声明</li><li>块级作用域（ES5：全局作用域 + 函数作用域）</li><li>const一旦声明变量，就必须立即初始化，不能留到以后赋值</li><li>const声明常量的局限性（仅针对变量指针的不变而非值，如数组等依旧可以改变）（考虑Object.freeze）</li><li>变量声明方式归纳：var、function、let、const、import、class</li></ol><h3 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h3><ol><li>不完全解构和解构不成功</li><li>数组解构依赖Iterator接口（按次序）</li><li>对象解构依赖属性（按属性名）</li><li>默认值，生效的条件是值必须严格等于undefined，如null是不会生效的</li><li>对象解构是找到同名属性再赋值，属性重命名（别名）</li><li>嵌套解构</li><li>解构赋值可以拿到原型链上的属性</li><li>使用圆括号解决已声明变量的解构赋值报错问题（一般不要这么做，代码丑陋而且容易出问题）</li><li>数组可以以下标的方式进行对象解构（这没有任何意义，因为我们可以直接使用下标对数组进行访问）</li><li>字符串会被当做数组进行解构</li><li>数值和布尔值会被当成其对应的包装对象进行解构</li><li>函数参数解构赋值，参数默认值和变量默认值<h5 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h5><ol><li>模块加载</li><li>Map遍历，for…of =&gt; [key, value]形式</li><li>函数参数默认值</li><li>交换变量的值（数组按顺序，对象按属性）</li></ol></li></ol><blockquote><p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p></blockquote><h3 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h3><ol><li>Unicode表示法</li><li>字符串遍历（注意和for循环的区别）</li><li>模板字符串</li><li>标签模板（函数调用）</li><li>API更新：<ul><li>String.fromCodePoint()</li><li>String.raw()</li><li>s.codePointAt()</li><li>s.normalize()</li><li>s.includes(), startsWith(), endsWith()</li><li>s.repeat()</li><li>s.padStart()，padEnd()</li><li>s.trimStart()，trimEnd()</li><li>s.matchAll()</li></ul></li></ol><h3 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h3><ol><li>构造函数行为</li><li>字符串API正则表达式</li><li>u修饰符</li><li>RegExp.prototype.unicode属性</li><li>y修饰符</li><li>RegExp.prototype.sticky</li><li>RegExp.prototype.flags</li><li>s 修饰符：dotAll 模式 </li><li>后行断言</li><li>Unicode 属性类</li><li>具名组匹配</li><li>String.prototype.matchAll</li></ol><h3 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h3><ol><li>Number.isFinite()</li><li>Number.isNaN()</li><li>Number.parseInt()</li><li>Number.parseFloat()</li><li>Number.isInteger()</li><li>Number.EPSILON</li><li>Number.isSafeInteger()</li><li>Math.trunc()</li><li>Math.sign()</li><li>Math.cbrt()</li><li>Math.clz32()</li><li>Math.imul()</li><li>Math.fround()</li><li>Math.hypot()</li><li>Math.expm1()</li><li>Math.log1p()</li><li>Math.log10()</li><li>Math.log2()</li><li>Math.sinh()</li><li>Math.cosh()</li><li>Math.tanh()</li><li>Math.asinh()</li><li>Math.acosh()</li><li>Math.atanh()</li><li>指数运算符：**</li><li>BigInt数据类型</li></ol><h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><ol><li>函数参数默认值</li><li>rest参数</li><li>name属性</li><li>箭头函数</li></ol><h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> ES版本 </tag>
            
            <tag> ES 6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资讯-Babel</title>
      <link href="/2019/12/14/%E8%B5%84%E8%AE%AF-Babel/"/>
      <url>/2019/12/14/%E8%B5%84%E8%AE%AF-Babel/</url>
      
        <content type="html"><![CDATA[<p>官方博客：<a href="https://babeljs.io/blog/" target="_blank" rel="noopener">https://babeljs.io/blog/</a><br>Github：<a href="https://github.com/babel/babel" target="_blank" rel="noopener">https://github.com/babel/babel</a><br>官网：<a href="https://babeljs.io/" target="_blank" rel="noopener">https://babeljs.io/</a><br>stackoverflow：<a href="https://stackoverflow.com/questions/tagged/babeljs" target="_blank" rel="noopener">https://stackoverflow.com/questions/tagged/babeljs</a><br>twitter：<a href="https://twitter.com/babeljs" target="_blank" rel="noopener">https://twitter.com/babeljs</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Babel </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 资讯 </tag>
            
            <tag> 前端资讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Babel配置</title>
      <link href="/2019/12/14/Babel%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/12/14/Babel%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>我们知道，Babel是基于插件的，但要使用哪些插件，这个是取决于我们自己的需求的，我们可以通过配置文件的形式明确指定Babel使用哪些插件进行转换工作。</p><h3 id="二、如何使用"><a href="#二、如何使用" class="headerlink" title="二、如何使用"></a>二、如何使用</h3><p>官网提供了多种不同的配置方式：</p><ol><li>babel.config.js<ul><li>动态创建配置</li></ul></li><li>.babelrc<ul><li>静态配置</li></ul></li><li>package.json#babel<ul><li>同.babelrc</li></ul></li><li>.babelrc.js（<strong>推荐：基本可以满足大多数场景</strong>）<ul><li>基本和.babelrc相同，但可以使用JavaScript</li><li>可以使用任何Node.js API去做一些额外的事情，如使用执行环境变量做动态的配置</li></ul></li><li>使用命令号工具<ul><li>@babel/cli</li></ul></li><li>使用babel API<ul><li>@babel/core</li></ul></li></ol><h3 id="三、核心配置"><a href="#三、核心配置" class="headerlink" title="三、核心配置"></a>三、核心配置</h3><ol><li><p>presets<br>presets是Babel的一系列预设插件组合，常用的有@babel/preset-env、@babel/preset-react，这些present都发布到了npm上，你也可以创建自己的preset来个性化定制plugin组合。</p></li><li><p>plugins<br>babel是一个编译器（源代码 =&gt; 目标代码），它运行时执行三个步骤：解析（源代码）、（按规则）转化、生成（新代码）。每一个步骤都是由plugin来完成的，所以说babel是基于plugin的（和webpack的思想有点像）。<br>这是官网列举的<a href="https://babeljs.io/docs/en/plugins" target="_blank" rel="noopener">plugins</a>列表。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Babel </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新认识Babel</title>
      <link href="/2019/12/13/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86Babel/"/>
      <url>/2019/12/13/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86Babel/</url>
      
        <content type="html"><![CDATA[<h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>ES标准每年都会更新，但是用户使用的浏览器或者其他目标环境（如node），并不会及时作出响应或更新，然而每个新版本的新特性对于每个开发者而言，都有不少的诱惑，因为新特性一般都是为了解决旧版本的一些特定问题或者提升开发者的开发效率而被加入标准的。鉴于这种开发环境和实际应用环境不匹配的情况，有些会使用Polyfill一些库，有些则需要Hack代码，Babel正是为帮你做这些事情而产生的。</p><h3 id="二、-什么是Babel？"><a href="#二、-什么是Babel？" class="headerlink" title="二、 什么是Babel？"></a>二、 什么是Babel？</h3><blockquote><p>Babel是一个可以将ECMAScript 2015+ 代码转化为低版本浏览器能支持的ES版本的工具链，或者将一些非ES标准的JS超集（如TS）转换为目标环境可识别的ES代码。</p></blockquote><p>主要做以下这些事：</p><ol><li>语法转换</li><li>Polyfill目标环境没有的一些功能</li><li>代码转换</li><li>其他（如JS扩展、jsx、或自定义插件）</li></ol><h3 id="三、如何使用"><a href="#三、如何使用" class="headerlink" title="三、如何使用"></a>三、如何使用</h3><ol><li>使用cli</li><li>使用API</li><li>Nodejs环境中可以使用@babel/register或babel-node：原理是在require hook，在require加载之前将先使用babel进行编译</li></ol><h3 id="四、Babel是如何做到的？"><a href="#四、Babel是如何做到的？" class="headerlink" title="四、Babel是如何做到的？"></a>四、Babel是如何做到的？</h3><p><img alt="Babel 组成" data-src="/images/2019-12-14_06-11-12.png"></p><h3 id="五、扩展"><a href="#五、扩展" class="headerlink" title="五、扩展"></a>五、扩展</h3><p>Babel是基于插件的，所以并不一定要将Babel定义在ES规范的局限之下（当然产出肯定是ES标准没错了），只要你愿意，可以使用任意奇葩的插件，甚至自定义插件，用来转换你自定义的奇奇怪怪的代码。总之就是，每个插件可以将你相应类型或有相应格式的文本转化输出为你期望得到的目标代码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Babel </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React_v15-拾荒记</title>
      <link href="/2019/12/12/React15%E6%8B%BE%E8%8D%92%E8%AE%B0/"/>
      <url>/2019/12/12/React15%E6%8B%BE%E8%8D%92%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h3><blockquote><p>jsx是React.createElement(component, props, …children)函数的一个语法糖，需要babel插件（preset-react）做转换。</p></blockquote><p>需要注意的点：</p><ol><li>React必须在当前作用域</li><li>自定义组件必须首字母大写</li><li>可以使用点标记(如：MyComponent.HeaderComponent)</li><li>Booleans、Null、和Undefined会被忽略(可以使用String(undefined/false/null))</li><li>属性值默认为true</li></ol><h3 id="setState-函数"><a href="#setState-函数" class="headerlink" title="setState()函数"></a>setState()函数</h3><p>setState函数有时是异步执行的，处于对性能的考虑，React有时会将多个setState操作合并成一个更新操作。</p><p>当你调用setState函数时，React会将需要更新的state与原state进行合并(merge)，合并的过程是浅拷贝。</p><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>this指向问题，使用箭头函数或bind</p><p><strong>为什么：</strong> js的class机制</p><h3 id="list和key"><a href="#list和key" class="headerlink" title="list和key"></a>list和key</h3><p>diff算法</p><h3 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h3><p>受控组件和非受控组件</p><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>注意渲染的条件必须返回boolean值，如：</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h3&gt;你好啊$&#123; 0 &amp;&amp; "我很好"&#125;&lt;/h3&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 显示会将0也显示出来</span></span><br><span class="line"><span class="comment">// 因为：Booleans, Null, and Undefined Are Ignored</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown</title>
      <link href="/2019/12/11/markdown/"/>
      <url>/2019/12/11/markdown/</url>
      
        <content type="html"><![CDATA[<h3 id="背景（表象）"><a href="#背景（表象）" class="headerlink" title="背景（表象）"></a>背景（表象）</h3><p>markdown可以说是轻量级的HTML语言，标记也更加简洁。它的特点和优势也很明显：简单易用，使用格式标记进行快速文本排版，与其相比，一般富文本编辑器都显得过于笨重和复杂。</p><h3 id="如何使用（功能应用）"><a href="#如何使用（功能应用）" class="headerlink" title="如何使用（功能应用）"></a>如何使用（功能应用）</h3><p><a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></p><h3 id="实现原理-（组成结构）"><a href="#实现原理-（组成结构）" class="headerlink" title="实现原理 （组成结构）"></a>实现原理 （组成结构）</h3><p>不同的设备场景下实现的解析器可能会略有不同，如用浏览器显示的话，需要将markdown标签转换为HTML标签，如果在其他客户端使用的话，可能会将其转化为对应客户端UI显示的标记语言或代码。总的来说，markdown就是一个定义了标签(标记)和显示之间的一套规则或规范，而可以实现这套规则的代码就叫解析器。</p><h3 id="功能扩展（二次封装）"><a href="#功能扩展（二次封装）" class="headerlink" title="功能扩展（二次封装）"></a>功能扩展（二次封装）</h3><p>基于传统的markdown语法，可能已经无法满足部分人的需求，因此市面上又有不少的扩展，这里就列一个我喜欢的：</p><ol><li><a href="https://www.mdeditor.com/" target="_blank" rel="noopener">mdeditor</a></li></ol><h3 id="个人常用工具"><a href="#个人常用工具" class="headerlink" title="个人常用工具"></a>个人常用工具</h3><ol><li><a href="https://www.mdeditor.com/" target="_blank" rel="noopener">mdeditor</a> ：Web PC端在线编辑器</li><li><a href="https://www.typora.io/" target="_blank" rel="noopener">typro</a>：下载客户端编辑器</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 日常工具 </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论如何优化一个Webpack项目</title>
      <link href="/2019/12/08/%E8%AE%BA%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E4%B8%80%E4%B8%AAWebpack%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/12/08/%E8%AE%BA%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E4%B8%80%E4%B8%AAWebpack%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近在写脚手架的模板(generator-ywc:react)，想把antd引进来，方便布局之类的。但是，发现打包后的main.bundle特别大，足足1M多。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>于是使用webpack-bundle-analyzer分析了下，主要原因有：</p><ol><li>antd</li><li>mockjs</li><li>moment</li><li>react</li></ol><h3 id="逐个解决"><a href="#逐个解决" class="headerlink" title="逐个解决"></a>逐个解决</h3><p>首先Antd组件是使用babel-plugin-import方式按需加载的，其中主要是icon全量引入(&gt;500kb)。官网给出的方案是：使用resolve.alias（<a href="https://github.com/ant-design/ant-design/issues/12011#issuecomment-420038579" target="_blank" rel="noopener">https://github.com/ant-design/ant-design/issues/12011#issuecomment-420038579</a> ）。</p><p>然后mockjs、moment引入都可以单独在entry设置，之后再利用splitChunks即可将这两个类库分离出来单独加载，而且大多时候都可以将其设置为异步加载。</p><p>接着react、react-dom也可以单独的entry形式设置，但要考虑到脚本的执行顺序，一定要将其放在前面，并同步加载。</p><p>最后webpack的配置文件entry看起来就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    lib: [<span class="string">"@babel/polyfill"</span>, <span class="string">"react"</span>, <span class="string">"react-dom"</span>],</span><br><span class="line">    moment: <span class="string">"moment"</span>,</span><br><span class="line">    mockjs: <span class="string">"mockjs"</span>,</span><br><span class="line">    app: path.join(process.cwd(), <span class="string">"src/index.jsx"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><img data-src="/images/2019-12-08_23-13-37.png"><h3 id="延伸（如何使用Webpack优化一个项目）"><a href="#延伸（如何使用Webpack优化一个项目）" class="headerlink" title="延伸（如何使用Webpack优化一个项目）"></a>延伸（如何使用Webpack优化一个项目）</h3><img data-src="/images/2019-12-08_23-11-08.png"><h3 id="在线演示"><a href="#在线演示" class="headerlink" title="在线演示"></a>在线演示</h3><p><a href="http://106.13.230.115" target="_blank" rel="noopener">http://106.13.230.115</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Webpack </tag>
            
            <tag> 系统优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yume-ywc项目新增React脚手架</title>
      <link href="/2019/12/03/yume-ywc%E9%A1%B9%E7%9B%AE%E6%96%B0%E5%A2%9EReact%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
      <url>/2019/12/03/yume-ywc%E9%A1%B9%E7%9B%AE%E6%96%B0%E5%A2%9EReact%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="前言（废话）"><a href="#前言（废话）" class="headerlink" title="前言（废话）"></a>前言（废话）</h3><p>很久前就想写这个脚手架了，一直没有时间。最近比较空了，先把之前写一半的react脚手架第一个版本(0.1.0)搞完并发布。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>和众多创建脚手架的目的一致：</p><ol><li>快速创建一个初始化项目</li><li>集成众多依赖，或者更高层次的封装，让使用者觉得更加易用和简单</li><li>市面上的众多脚手架大多有一些毛病：<ul><li>可配置性差(create-react-app)</li><li>版本更新较慢(dva)，无法使用较新版本的类库</li></ul></li></ol><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>将依赖配置不直接写入package.json，而是通过yeoman工具在使用者执行脚手架命令时动态写入package.json。整个模板的是从这两年的项目经验总结探索出来的，集成了redux、react-router、redux-saga、css module等功能。</p><h3 id="框架基础结构"><a href="#框架基础结构" class="headerlink" title="框架基础结构"></a>框架基础结构</h3><img data-src="/images/ywc-react-structure.png"><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ol><li><p>安装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yo</span><br><span class="line">npm install -g generator-ywc</span><br></pre></td></tr></table></figure></li><li><p>创建项目</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir yourAPPDir</span><br><span class="line">cd yourAPPDir</span><br><span class="line">yo ywc:react  <span class="comment">//ywc: Yume-web-cli:react</span></span><br></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure></li></ol><p>看到控制台编译成功后，在浏览器打开<a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a> 即可看到下面页面：<br><img data-src="/images/2019-12-03_16-07-49.png"></p><h3 id="有用链接"><a href="#有用链接" class="headerlink" title="有用链接"></a>有用链接</h3><p>Github: <a href="https://github.com/iWuzhi/yume-ywc/tree/master/generators/react" target="_blank" rel="noopener">https://github.com/iWuzhi/yume-ywc/tree/master/generators/react</a><br>Issues: <a href="https://github.com/iWuzhi/yume-ywc/issues" target="_blank" rel="noopener">https://github.com/iWuzhi/yume-ywc/issues</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> React </tag>
            
            <tag> 脚手架 </tag>
            
            <tag> yume-ywc </tag>
            
            <tag> yeoman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js事件循环机制 ？</title>
      <link href="/2019/11/23/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/11/23/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>MDN上对事件循环这一块也是说的比较模糊，随便百度一下，什么CSDN啊、简书啊、脚本之家啊、segmentfault啊、阮一峰啊乱七八糟的各种流弊哄哄的博客。大多都是给你写个例子跑跑，看看console的顺序，然后搬两张大佬的图过来，再做一番推测。。。看完之后多多少少了解了点吧。更重的要，我在其中挖到了一些比这些博客更有价值的链接。</p><p>Philip Roberts（没有计算机学位的小哥，和我一样呢，优秀）在JSConf关于event loop的演讲：<a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank" rel="noopener">https://www.youtube.com/watch?v=8aGhZQkoFbQ</a> ，如果想要快速、简单的熟悉event loop，先去看这个视频，绝对没错。大佬在视频中对执行栈、异步队列，不同模块的异步事件如何有序的进行异步调用做了可视化的演示。</p><p>Jake的博客：<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a> ，这位大佬是更加倾向于从规范的角度去解释这个问题，当然文中也有一些可视化的演示。</p><p>接下来谈谈我个人的理解：</p><p>首先，事件循环不是ECMAScript的规范，而是HTML的规范，没错，是HTML的规范，这一点估计就有很多人是理解错误的！（事件循环规范：<a href="https://html.spec.whatwg.org/#event-loops" target="_blank" rel="noopener">https://html.spec.whatwg.org/#event-loops</a> ）也就是说，这是使用HTML规范的客户端（一般是浏览器）需要实现的功能。</p><p>下面是结合两位大佬画的一个小学生水平的图示：要真正的去了解的话，估计还是得把那个规范读个好几遍，现在就先这样吧。<br><img data-src="/images/2019-11-23_22-54-57.png"></p><p>理论就这样了，实践的话，私底下做做就可以了，主要还是写写常见的异步任务，定时器、promise啥的，然后根据所了解到的，先在脑子里跑一遍，再去浏览器验证，多搞几次估计就很熟练了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> HTML规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux原理</title>
      <link href="/2019/11/14/redux%E5%8E%9F%E7%90%86/"/>
      <url>/2019/11/14/redux%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>redux核心概念和flux类似，除了一些简化外，我觉得最重要的是它的中间件。</p><p>每个中间件接受一个(包装过的)dispatch函数，并返回一个新的(包装过)dispatch函数，可以作为下一个中间件的参数，以达到将中间件串起来的目的。然后借助Array.reduce函数将中间件层层包裹，比如中间件函数为[f1, f2, f3]，执行reduce后为(f1(f2(f3())))。</p><p>redux中间件源码中最重要的感觉就一行代码：funcs.reduce((a, b) =&gt; (…args: any) =&gt; a(b(…args)))，不过真的很难理解，函数嵌套的太深了，不过也就做了函数嵌套一件事。</p><p>至于在react中使用的话，也就是提供一个外层的container做state与store的同步，在react-redux中，是用context的搞的，这样的话，可以不用props层层传递。</p><p>像redux-thunk这种的话，源码就一句，action(dispatch, getState, extraArgument)，我们正常情况下action是一个特定格式的对象，但如果是函数的话，就把它当做一个异步任务，redux-thunk就会处理，然后action是我们自己定义的函数，但会接收到dispatch, getState参数，我们可以在这个action里面很多事情，调接口、各种耗时任务，至于何时调用dispatch，由你自己决定，其实就是延迟调用dispatch而已。</p><p>当然我们完全可以不用redux-thunk，而是将异步流程从redux流程分离，在执行完异步任务后再直接发起dispatch，当然，这样可能要把代码写在View层了。</p><p>像redux-saga就比较复杂了，毕竟人家的目标是管理side effects，就像上面的一些异步任务，会涉及到先执行哪一个effect、同步执行、异步执行等等乱七八糟的东西，还没仔细看，等研究后单独记录下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> flux </tag>
            
            <tag> redux </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flux源码日记</title>
      <link href="/2019/11/12/flux%E6%BA%90%E7%A0%81%E6%97%A5%E8%AE%B0/"/>
      <url>/2019/11/12/flux%E6%BA%90%E7%A0%81%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>官网：<a href="https://facebook.github.io/flux/，" target="_blank" rel="noopener">https://facebook.github.io/flux/，</a> 官方示例代码用flow搞得，看得还是有点烦，但主体结构还算是认识，下图虚线框内上半部分就是flux的核心思想了，单向数据流，固定的更改状态方式，虚线框下半部分就是flux如何做到store和react的state同步，其实就是事件通知，最后还是依赖react的状态与页面同步。</p><img data-src="/images/2019-11-12_16-15-27.png">]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> flux </tag>
            
            <tag> redux </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this和对象原型</title>
      <link href="/2019/10/27/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/"/>
      <url>/2019/10/27/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-关于this"><a href="#第一章-关于this" class="headerlink" title="第一章 关于this"></a>第一章 关于this</h3><ol><li><p>this误区：</p><ul><li>误区一：指向函数自身</li><li>误区二：指向函数的作用域</li></ul></li><li><p>到底this是什么<br>this是在运行时绑定的，它的上下文取决于函数调用时的各种条件，this的绑定和函数的位置没有任何关系，只取决于函数的调用方式，当一个函数被调用时，会创建一个活动记录（执行上下文），这个记录会包含函数在哪里被调用、函数的调用方式、传入的参数等信息，this就是这个记录的一个属性，会在函数执行的过程中用到。</p></li></ol><h3 id="第二章-this全面解析"><a href="#第二章-this全面解析" class="headerlink" title="第二章 this全面解析"></a>第二章 this全面解析</h3><p>函数的this是在调用时绑定的，完全取决于函数的调用位置</p><h5 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h5><ol><li><p>默认绑定：独立函数调用（绑定到全局对象或undefined，取决于是否是严格模式）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo();  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>隐式绑定：函数调用位置是否有上下文对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ol><p><strong><em>隐式丢失</em></strong>：被隐式绑定的函数会丢失绑定对象，也就是说，它会应用默认绑定规则，如下示例，函数调用位置引用的是函数本身，即函数独立调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo;  <span class="comment">// 函数别名</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// 全局对象属性</span></span><br><span class="line">bar();  <span class="comment">// "oops, global"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种常见的情况是传入回调函数时：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>;</span><br><span class="line">doFoo(obj.foo);  <span class="comment">// 参数传递其实就是一种隐式赋值，所以结果和上面例子一致</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>显式绑定（call/apply、bind）</p><ul><li>硬绑定</li><li>API调用的”上下文”：一些内置函数、三方库提供的额外参数，作用和bind类似</li></ul></li><li><p>new 绑定<br>和传统面向对象的语言不一样，javascript中new操作符的作用完全不一样：</p><ul><li>创建一个全新的对象</li><li>这个新对象会被执行Prototype连接</li><li>这个心对象会绑定到函数调用的this</li><li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象</li></ul></li></ol><h5 id="绑定规则优先级"><a href="#绑定规则优先级" class="headerlink" title="绑定规则优先级"></a>绑定规则优先级</h5><ol><li>new绑定：绑定到新创建的对象</li><li>显式绑定：绑定到指定对象</li><li>隐式绑定：绑定到引用上下文(对象)</li><li>默认绑定：严格模式下绑定到undefined，否则绑定到全局对象</li></ol><h5 id="被忽略的this"><a href="#被忽略的this" class="headerlink" title="被忽略的this"></a>被忽略的this</h5><p>在进行显示绑定时，某些情况你会将null/undefined作为绑定对象（apply展开数组，bind函数柯里化），这些值在调用时会被忽略，实际应用默认绑定。但这可能会带来一些副作用，比如某个函数确实使用了this，那就会对全局属性造成影响，后果无法预估。</p><p>另一种更安全的做法是，传入一个特殊的对象，把this绑定到这个对象不会对你的程序产生任何副作用，一个空的非委托对象，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ø = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把数组展开</span></span><br><span class="line">foo.apply(ø, [<span class="number">2</span>, <span class="number">3</span>]);  <span class="comment">// 2, 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用bind进行函数柯里化</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(ø, <span class="number">2</span>);</span><br><span class="line">bar(<span class="number">3</span>);  <span class="comment">// 2, 3</span></span><br></pre></td></tr></table></figure><h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><p>箭头函数不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this，具体来说，箭头函数会继承外层函数调用的this绑定。</p><h3 id="第三章-对象"><a href="#第三章-对象" class="headerlink" title="第三章 对象"></a>第三章 对象</h3><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>对象可以通过两种形式定义：声明形式和构造形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的文字语法：</span></span><br><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  key: <span class="string">"value"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造形式：</span></span><br><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObj.key = <span class="string">"value"</span>;</span><br></pre></td></tr></table></figure><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>对象是JavaScript的基础，在JavaScript中一共有六种主要(简单基本)类型：</p><ul><li>string</li><li>number</li><li>boolean</li><li>null </li><li>undefined</li><li>object</li></ul><p>简单基本类型本身并不是对象，”JavaScript中万物皆是对象”这显然是错误的，null有时会被当做一种对象类型，即对null执行typeof null时会返回字符串”object”，这是语言本省的一个bug。<br><strong><em>备注：</em></strong>在JavaScript中，二进制前三位都为0的话会被判断为object类型，null的二进制表示是全0，所以执行typeof时会返回”object”</p><h5 id="内置对象-函数"><a href="#内置对象-函数" class="headerlink" title="内置对象(函数)"></a>内置对象(函数)</h5><ul><li>String</li><li>Number</li><li>Boolean</li><li>Object</li><li>Function</li><li>Array</li><li>Date</li><li>RegExp</li><li>Error</li></ul><p>某些内置对象和基本类型很像，但它们并不一样，功能上倒是和一些面向对象语言的”装箱”类似，而且在必要时，string、number会自动转换成对象的内置对象。null和undefined没有对应的构造形式，Date只有构造形式，Object、Array、Function、RegExp无论使用文字形式还是构造形式，他们都是对象，不是字面量。Error很少在代码中显式创建，一般是在抛出异常时被自动创建，也可以使用new Error(…)这种构造形式来创建。</p><h5 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h5><p>对象的内容是由一些存储在特定命名位置的任意类型的值组成的，我们称之为属性。</p><ol><li><p>可计算属性名<br>ES6增加了可计算属性名，可以在文字形式中使用[]包裹一个表达式来当做属性名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prefix = <span class="string">"foo"</span>;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  [prefix + <span class="string">"bar"</span>]: <span class="string">"hello"</span>,</span><br><span class="line">  [prefix + <span class="string">"baz"</span>]: <span class="string">"world"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject[<span class="string">"foobar"</span>];  <span class="comment">// hello</span></span><br><span class="line">myObject[<span class="string">"foobaz"</span>];  <span class="comment">// world</span></span><br></pre></td></tr></table></figure></li><li><p>数组<br>数组有一套更加结构化的值存储机制。数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [<span class="string">"foo"</span>, <span class="number">42</span>, <span class="string">"bar"</span>];</span><br><span class="line">myArray.baz = <span class="string">"baz"</span>;</span><br><span class="line">myArray.length;  <span class="comment">// 3</span></span><br><span class="line">myArray.baz;  <span class="comment">// "baz"</span></span><br></pre></td></tr></table></figure></li></ol><p>无论添加了命名属性，数组的length值并不会发生改变。<br><strong><em>注意：</em></strong>如果你试图向数组添加一个属性，但是属性名”看起来”像一个数字，它会变成一个数值下标，因此会修改数组的内容，而不是添加一个属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [<span class="string">"foo"</span>, <span class="number">42</span>, <span class="string">"bar"</span>];</span><br><span class="line">myArray[<span class="string">"3"</span>] = <span class="string">"baz"</span>;</span><br><span class="line">myArray.length;  <span class="comment">// 4</span></span><br><span class="line">myArray[<span class="number">3</span>];  <span class="comment">// "baz"</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>复制对象<br>JavaScript中没有内置的copy函数，因为我们无法选择一个默认的复制算法，但却可以通过一些其他手段做到这一点。</p><ul><li>JSON序列化: 深度拷贝</li><li>Object.assign：浅度拷贝</li></ul></li><li><p>属性描述符</p><ul><li>Object.getOwnPropertyDescriptor(obj, prop)：获取属性描述符</li><li>Object.defineProperty(obj, prop, descriptor)：设置属性描述符<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(myObject, <span class="string">"a"</span>);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   value: 2,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">3</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>描述符属性的意义：</p><ul><li>writable：决定是否可以修改属性的值</li><li>configurable: 决定是否可以修改描述符，将configurable改成false是单向操作，无法撤销。例外是，可以将writable由true改为false，但无法由false改为true。configurable还会禁止删除这个属性，即delete语句会失败</li><li>enumerable：控制属性是否会出现在对象的枚举属性中，如是否出现在for…in循环中</li><li>value：定义该属性的值</li><li>get/set：定义属性访问时的特殊行为</li></ul><ol start="5"><li><p>（浅）不变性<br>所有的方法创建的都是浅不变性，也就是说，他们只会影响目标对象和他的直接属性，如果目标对象引用了其他对象，其他对象的内容不受影响，仍然是可变的。</p><ul><li>对象常量：使用writable + configurable可以创建一个真正的常量属性（不可修改、重定义或者删除）</li><li>禁止扩展：Object.preventExtensions(obj)禁止添加新的属性并且保留已有属性</li><li>密封：Object.seal()会创建一个”密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions()并把所有现有属性标记为configurable: false</li><li>冻结：Object.freeze()会创建一个”冻结对象”，这个方法实际上会在一个现有对象上调用Object.seal()，并把所有的”数据访问”属性标记为writable: false</li></ul></li><li><p>[[Get]]和[[Put]]<br>JavaScript在属性访问时，实现了[[Get]]和[[Put]]操作，类似函数。ES5中可以使用getter和setter部分改写默认操作，但是只能应用在单个属性上，getter是一个隐藏函数，会在获取属性值时调用，setter也是一个隐藏函数，会在设置属性值时调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：对象文字语法</span></span><br><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="keyword">get</span> a() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._a_;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> a(val) &#123;</span><br><span class="line">    <span class="keyword">this</span>._a_ = val * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.a = <span class="number">2</span>;</span><br><span class="line">myObj.a;  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：属性描述符</span></span><br><span class="line"><span class="comment">// 忽略value和writable特性，取而代之的是set和get</span></span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">"b"</span>, &#123;</span><br><span class="line"> <span class="keyword">get</span>: function() &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.a * <span class="number">2</span>;</span><br><span class="line"> &#125;,</span><br><span class="line"> enumerable: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line">myObject.a;  <span class="comment">// 2</span></span><br><span class="line">myObject.b;  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li><li><p>（属性）存在性</p><ul><li>in操作符会检查属性是否在对象及其[[Prototype]]原型链中，hasOwnProperty只会检查属性是否在当前对象中，不会检查[[Prototype]]链，所有的普通对象都可以通过对于Object.prototype的委托来访问hasOwnProperty()，但有的对象没有链接到Object.prototype（通过Object.create(null)来创建的对象），这种情况下，调用hasOwnProperty()会失败，这时可以使用Object.prototype.hasOwnProperty.call(myObject, “a”)，借用该方法并把它显示绑定到myObject上。</li><li>for…in循环有时会产生出令人意料之外的结果，因为这种枚举不仅会包含所有的数值索引，还会包含所有的可枚举属性，最好只在对象上应用for…in循环。</li><li>propertyIsEnumerable()会检查给定的属性名是否直接存在于对象中（而不是原型链上）并且满足enumerable: true</li><li>Object.keys()会返回一个数组，包含所有可枚举的属性</li><li>Object.getOwnPropertyNames()会返回一个数组，包含所有属性，无论它们是否可枚举<br>（目前）并没有内置的方法可以获取in操作符使用的属性列表（对象本省的属性以及[[Prototype]]链中的所有属性）</li></ul></li><li><p>（值）遍历</p><ul><li>数组：for循环，辅助迭代器（如forEach()、every()、some()）</li><li>for…in：根据循环中的属性索引取值</li><li>for…of：要求本身有迭代器，数组内置了迭代器，你可以在自己的对象中定义迭代器，从而使用for…of语法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line"> a: <span class="number">2</span>,</span><br><span class="line"> b: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="built_in">Symbol</span>.iterator, &#123;   </span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,  <span class="comment">// 这个比较关键，使其不可枚举</span></span><br><span class="line">  value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> ks = <span class="built_in">Object</span>.keys(o);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: o[ks[idx++]],</span><br><span class="line">          done: (idx &gt; ks.length)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="第四章-混合对象”类”"><a href="#第四章-混合对象”类”" class="headerlink" title="第四章 混合对象”类”"></a>第四章 混合对象”类”</h3><h5 id="类理论"><a href="#类理论" class="headerlink" title="类理论"></a>类理论</h5><p>面向对象编程强调的是数据和操作数据的行为本质上是互相关联的，类理论可以恰当的描述这种关系。类理论描述了一种代码的组织结构形式——一种在软件中对真实世界中问题领域的建模方法，类的一个核心概念是实例化、继承和多态（父类的通用行为可以被子类用更特殊的行为重写）。</p><p>类通过复制操作被实例化为对象形式。</p><h5 id="类的机制"><a href="#类的机制" class="headerlink" title="类的机制"></a>类的机制</h5><ul><li>实例化：由一个特殊的类方法构造，方法名通常和类名相同，被称为构造函数，大多需要new来调用构造新的实例</li><li>继承：子类会包含父类行为的原始副本，但是也可以重写所有继承的行为甚至定义新行为，类的继承其实就是复制</li><li>多态：任何方法都可以引用继承层次中高层的方法，在继承链的不同层次中一个方法名可以被多次定义，当调用方法时会自动选择合适的定义，多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。</li><li>多重继承：大多数面向对象的语言不会有多重继承，因为使用多重继承的代价太高（从多个父类继承到多个同名方法时无从选择）</li></ul><h5 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h5><p>JavaScript中的类和其他语言的并不一样。简单来说，JavaScript中只有对象，并不存在可以被实例化的”类”，一个对象不会被复制到其他对象，它们会被关联起来。</p><ol><li>显式混入：其实就是简单的将一个对象的属性复制到另一个对象，当然不能完全复制，如对象引用。复制的目的是模仿类模式。(this显式绑定规则)</li><li>隐身混入：借助this的隐式绑定规则，动态的为对象生成一样的属性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式混入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">sourceObj, targetObj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> sourceObj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> targetObj)) &#123;</span><br><span class="line">      targetObj[key] = sourceObj[key];  <span class="comment">// 并不会完全复制，有可能是对象引用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> targetObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Vehicle = &#123;</span><br><span class="line">  engines: <span class="number">1</span>,</span><br><span class="line">  ignition: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Turning on my engine,"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  drive: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ignition();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Steering and moving forward"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Car = mixin(Vehicle, &#123;</span><br><span class="line">  wheels: <span class="number">4</span>,</span><br><span class="line">  drive: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Vehicle.drive.call(<span class="keyword">this</span>);  <span class="comment">// 借用Vehicle.drive方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Rolling on all "</span> + <span class="keyword">this</span>.wheels + <span class="string">" wheels"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式混入</span></span><br><span class="line"><span class="keyword">var</span> Something = &#123;</span><br><span class="line">  cool: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = <span class="string">"Hello World"</span>;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="keyword">this</span>.count ? <span class="keyword">this</span>.count + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Something.cool();</span><br><span class="line">Something.greeting;  <span class="comment">// Hello World</span></span><br><span class="line">Something.count;  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> Another = &#123;</span><br><span class="line">  cool: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Something.cool.call(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Another.cool();</span><br><span class="line">Another.greeting;  <span class="comment">// Hello World</span></span><br><span class="line">Another.count;  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> 《你不知道的JavaScript》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>create-react-app</title>
      <link href="/2019/10/24/create-react-app/"/>
      <url>/2019/10/24/create-react-app/</url>
      
        <content type="html"><![CDATA[<p>这个的是React官网推荐的一个脚手架，文档地址：<a href="https://create-react-app.dev/。" target="_blank" rel="noopener">https://create-react-app.dev/。</a><br>足够简单，你根本都不用了解webpack、babel是个啥，非常适合初学者，但也有一个很大的弊端，就是可配置性。</p><p>这个脚手架本身的使用方式非常简单，看官网文档就行了，下面主要说说如何进行个性化配置：</p><p>首先，你需要用到eject命令将封装在react-scripts里的配置文件、相关依赖弹射出来，它会将内置的配置全部以文件的形式重新存放于你的项目中，你可能比较在意的就是webpack的配置和Babel的配置。配置的时候只需要改变config/webpack.config.js相应的属性即可，这样基本上和裸了一个webpack没啥区别，不过是帮你把一些需要的loader，plugin配置好，其中有些配置在你的项目中甚至根本用不到。</p><p>至此，可配置性问题也算是勉强解决了，可eject出来的配置真的是有点复杂，至少看起来非常复杂，它是根据不同的环境，启动不同的脚本(scripts)，然后设置不同的执行环境变量，动态设置不同的webpack配置，不像固定的webpack文件那样简洁明了。</p><p>总结一下就是，官网推荐简单易上手，可配置性基本为0，但也有勉强能用的解决方案(eject)。</p><p>反正我个人是非常不喜欢create-react-app的，社区也提供了其他类似脚手架：如rodhog。</p><p>这里有篇文章还不错：<a href="https://github.com/sorrycc/blog/issues/15" target="_blank" rel="noopener">https://github.com/sorrycc/blog/issues/15</a><br>不过rodhog这个项目好像好久没更新了。</p><p>近期也有尝试过umi，umi的设计思想像是模仿next.js，整体用下来感觉还是很不错的，足够简单，就是有一套自己的开发模式(框架固有模式)，可能稍微需要你去适应一下。</p><p>yeoman社区 (<a href="https://yeoman.io" target="_blank" rel="noopener">https://yeoman.io</a>) 也有提供一些个人开发者提供的不错的脚手架，有空可以去探索一下，说不定突然就灵感大发，写一个御用的脚手架。</p><p>官网还提到两个工具neutrinojs和nwb，看着牛逼哄哄的，还没仔细看。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
            <tag> 脚手架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html入门指南</title>
      <link href="/2019/10/23/html%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2019/10/23/html%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>第一次开始接触的时候，你可能会复制(从书上、网上、看视频手打)下面一段代码片段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Hello World !</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你用记事本、Sublime text、WebStorm等你习惯的编辑器，然后保存为.html格式的文件，接着你双击这个文件，你的默认浏览器自动打开(或者将文件拖拽到你喜欢的浏览器)，你看到了空白的浏览器中显示着“Hello World !”，你还看到了浏览器Tab的标题显示着“Document Title”。</p><p>你欣赏着自己的作品，心里默念一句：卧槽，HTML真简单，劳资5min就学会了。</p><p>简单使你的学习欲望顿时上升了一大截，在接下来的学习中，你又了解到各种新的词汇：<br>比如标签、文档、w3c、块元素、内联元素等。渐渐地你对HTML的结构开始熟悉起来了，知道HTML有固定的格式，这是因为规范如此。<br><b>备注</b>：<i><br>既然是规范，想必是为了众多浏览器能够统一实现API，规定HTML结构，浏览器只要按规范实现即可，也降低了开发者的学习成本，不用为每种不同的浏览器学习不同的语法，使用不同的代码编写同样的效果。谁来制定呢，当然是<a href="https://www.w3.org/TR/html52/" target="_blank" rel="noopener">w3c</a>了，后来w3c决定制定一个最终版HTML规范，就是以后再也不改了， 但是浏览器厂商却不同意，觉得HTML还是要更加灵活，于是就有了分歧，几个浏览器厂商联合起来又搞了个组织<a href="https://html.spec.whatwg.org/" target="_blank" rel="noopener">whatwg</a>，目前w3c的规范也是趋向于whatwg。<br></i></p><p>在逐渐深入的过程种你发现，学习HTML无非就是学习标签而已，只要记住了常用的标签，出门就能说自己精通HTML。</p><p><b>备注：</b><i>推荐一个网站: <a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML" target="_blank" rel="noopener">MDN</a>，MDN将HTML分为了四大模块进行介绍，<b>基础、多媒体与嵌入、表格、表单</b>，每个模块里又有更细的划分与详尽的介绍。</i></p><p>你挑选了一些常用的标签：div、h1~h5、a、form、label、button、input、textarea、select + option、span、ol/ul + li、table、img。这些标签你每个都手敲了一遍，或者根据网上的例子，看看在浏览器中的真实展示效果。</p><p>至此，你的标签储备足够你日常使用了。学习了别人的规范，接下来就得规范自己了，什么代码风格、语义化啊。</p><p>HTML真的是太简单了，就算是你平时一直在用，也不会出现什么特别的问题值得你去积累，去研究。</p><p>对于HTML的学习，个人觉得真额是考验单词储备量，平时真正用到的也就那几个。</p><p><b>一些常用的链接：</b></p><ol><li>一个很完整的Table例子：<a href="https://roy-tian.github.io/mdn-examples/html/planets-data/" target="_blank" rel="noopener">https://roy-tian.github.io/mdn-examples/html/planets-data/</a></li><li>原生表单控件：<a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Forms/The_native_form_widgets" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Forms/The_native_form_widgets</a></li><li>块级元素：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements</a></li><li>行内元素：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elements" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elements</a></li><li>w3c组织：<a href="https://www.w3.org/TR/html52/" target="_blank" rel="noopener">https://www.w3.org/TR/html52/</a></li><li>whatwg组织：<a href="https://html.spec.whatwg.org/" target="_blank" rel="noopener">https://html.spec.whatwg.org/</a></li></ol><p>下面是我创建项目时经常用到的一个模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定文档编码方式，一般都是UTF-8--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--作者--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"iWuzhi"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--描述--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--关键词 作弊者会充斥大量的关键词扰乱搜索引擎，所以这个不再怎么使用了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"Keywords"</span> <span class="attr">content</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定文档的兼容模式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--阻止移动设备自动识别某些额外的功能，如拨打电话功能，主要针对Safari--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no,email=no,address=no"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--防止页面被缓存--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"pragma"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"cache-control"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"expires"</span> <span class="attr">content</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--站点图标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">href</span>=<span class="string">"favicon.ico"</span> <span class="attr">type</span>=<span class="string">"image/x-icon"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--标题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>通用html模板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术总结（2017-8~2019-10）</title>
      <link href="/2019/10/22/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%882017-8-2019-10%EF%BC%89/"/>
      <url>/2019/10/22/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%882017-8-2019-10%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这两年主线Web，然后周边杂七杂八的副本也刷了不少，这里把用过的所有东西都列出来，方便之后整理吧。</p><h3 id="核心基础技术"><a href="#核心基础技术" class="headerlink" title="核心基础技术"></a>核心基础技术</h3><ol><li>html</li><li>css</li><li>javascript</li></ol><h3 id="核心基础技术扩展"><a href="#核心基础技术扩展" class="headerlink" title="核心基础技术扩展"></a>核心基础技术扩展</h3><ol><li>css技术扩展：less, sass/scss, postcss, style-components, css-module</li><li>javascript扩展：TypeScript</li></ol><h3 id="React全套"><a href="#React全套" class="headerlink" title="React全套"></a>React全套</h3><ol><li>react</li><li>react-dom</li><li>react-router</li><li>react-router-dom</li><li>react-loadable</li></ol><h3 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h3><ol><li>npm(cnpm, npx)</li><li>yarn</li></ol><h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><ol><li>Webpack</li><li>Parcel</li><li>Rollup</li></ol><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><ol><li>redux：redux-saga，redux-thunk</li><li>mobx</li></ol><h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><ol><li>PropTypes</li><li>Flow</li></ol><h3 id="API规范"><a href="#API规范" class="headerlink" title="API规范"></a>API规范</h3><ol><li>REST</li><li>GraphQL</li></ol><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><ol><li>lodash</li><li>moment</li><li>classnames</li><li>numerial</li><li>RxJS</li><li>Ramda</li></ol><h3 id="测试框架（接触的有点少，真得找个机会好好体会一下了）"><a href="#测试框架（接触的有点少，真得找个机会好好体会一下了）" class="headerlink" title="测试框架（接触的有点少，真得找个机会好好体会一下了）"></a>测试框架（接触的有点少，真得找个机会好好体会一下了）</h3><ol><li>Mocha</li><li>Jest</li><li>Chai </li></ol><h3 id="静态文档生成"><a href="#静态文档生成" class="headerlink" title="静态文档生成"></a>静态文档生成</h3><ol><li>docz: 基于Gatsby</li><li>Gatsby</li><li>storybook</li></ol><h3 id="桌面开发"><a href="#桌面开发" class="headerlink" title="桌面开发"></a>桌面开发</h3><ol><li>Electron</li></ol><p>husky<br>代码美化，格式化<br>react-styleguidist<br>source-map-explorer<br>graphql<br>dotenv<br>dotenv-expand<br>semver</p><p>http协议<br>计算机网络</p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术总结 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《CSS世界》读书笔记</title>
      <link href="/2019/09/18/%E3%80%8ACSS%E4%B8%96%E7%95%8C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8B/"/>
      <url>/2019/09/18/%E3%80%8ACSS%E4%B8%96%E7%95%8C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h3><p>本书中CSS世界特指CSS2.1。</p><p>这个世界的事情只要发生了，都是有原因的，CSS世界的出现也不例外。要想深入理解CSS属性的一些设计原因、表现原理，离不开当时的历史环境，CSS世界的诞生就是为图文信息展示服务的。</p><p>作者认为，（文档）”流”是影响整个CSS世界的一个重要因素，”流”是一种基本的定位和布局机制，可以形象描述成CSS世界中引导元素排列和定位的一条看不见的”水流”，当然”流”可以被破坏（特殊布局），流向亦可以改变。</p><h3 id="第二章-需提前了解的术语和概念"><a href="#第二章-需提前了解的术语和概念" class="headerlink" title="第二章 需提前了解的术语和概念"></a>第二章 需提前了解的术语和概念</h3><ol><li>属性：CSS世界内置的固有属性，每个属性都有不同的作用，用来定制我们自己的页面</li><li>值：一般包括以下类型（与属性值关系密切）<ul><li>数值(z-index: 2)</li><li>百分比(height: 30%)</li><li>颜色值(red, #000)</li></ul></li><li>关键字：CSS内置的一些固定值(transparent、solid、red等)</li><li>变量（本书不做介绍）</li><li>长度单位：<ul><li>时间单位：s, ms</li><li>角度单位：deg, rad</li><li>长度单位: px, em</li><li>其他：vh、vw等</li></ul></li><li>功能符（css函数）：<ul><li>rgba</li><li>hsla</li><li>calc</li><li>url等</li></ul></li><li>属性值：值 + 关键字 + 功能符</li><li>声明：属性名 + 属性值</li><li>声明块：花括号（{}）包裹的一系列声明</li><li>规则或规则集：选择器 + 声明块</li><li>选择器：瞄准目标元素的东西</li><li>关系选择器：根据元素之间的关系选择元素的选择器</li><li>@规则：以@字符开始的一些规则，像@media、@font-face、@page、@support</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;  <span class="comment">/* color是属性，red是值, red也是关键字(代表红颜色) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CSS世界中的”未定义行为”"><a href="#CSS世界中的”未定义行为”" class="headerlink" title="CSS世界中的”未定义行为”"></a>CSS世界中的”未定义行为”</h5><p>web标准未定义的行为表现，（甚至标准已定义的表现）各大浏览器厂商表现并不一致，默认样式不一致等。</p><h3 id="第三章-流、元素与基本尺寸"><a href="#第三章-流、元素与基本尺寸" class="headerlink" title="第三章 流、元素与基本尺寸"></a>第三章 流、元素与基本尺寸</h3><p>width和height作用于content-box（当然可以凭借box-sizing更改），width: auto作用于不用类型的盒子（模型）上，会有不同的效果：充分利用可用空间(div)、收缩与包裹(span)、收缩到最小(table)、超出容器限制(white-space: nowrap)</p><p><code>书中特技：</code></p><ol><li><p>在绝对定位模型中，默认情况元素的宽度表现是”包裹性”，宽度由内部尺寸决定，但是，当left/right或top/bottom对立方位的属性值同事存在的时候，元素的宽度表现为”格式化”宽度，如下可以间接设置宽度和高度（高度自适应100%）</p><img style="width: 800px; margin: 0;" data-src="/images/1568877786779.jpg"></li><li><p>一行文字居中，多行文字居左，其实就是用两个容器来控制，外面控制居中，里面控制居左，如下：</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"out"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>一些文字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.out</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;  <span class="comment">/* 我能一行居中 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: left;  <span class="comment">/* 我能多行居左 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实例：<a href="https://demo.cssworld.cn/3/2-5.php" target="_blank" rel="noopener">https://demo.cssworld.cn/3/2-5.php</a></p><h5 id="首选最小宽度（指元素最适合的最小宽度）"><a href="#首选最小宽度（指元素最适合的最小宽度）" class="headerlink" title="首选最小宽度（指元素最适合的最小宽度）"></a>首选最小宽度（指元素最适合的最小宽度）</h5><img style="width: 400px; margin: 0;" data-src="/images/1568880343740.jpg"><p>容器将宽度设置为0，子元素的宽度并不为0，但会影响到布局，从布局的角度来看，子元素也的确是不见了(不占位置)。</p><p><code>书中奇技淫巧：</code></p><ol><li><p>利用中英(连续英文单词不换行)文的最小宽度不同，可以构造类似凹凸的图形。<br>具体示例：<a href="https://demo.cssworld.cn/3/2-6.php" target="_blank" rel="noopener">https://demo.cssworld.cn/3/2-6.php</a></p></li><li><p>height: 100%：必须给与父元素固定高度或使用绝对定位。</p></li><li><p>实现子元素等高：子元素自动撑开父元素，父元素position设置为relative，其他子元素再设置position: absolute, height： 100%，可实现这些绝对定位的子元素与撑开父元素的子元素等高。如下：<br>具体示例：<a href="https://demo.cssworld.cn/3/2-12.php" target="_blank" rel="noopener">https://demo.cssworld.cn/3/2-12.php</a> </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.prev</span>, </span><br><span class="line"><span class="selector-class">.next</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>; <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: .<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.prev</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#cd0000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.next</span> &#123;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#34538b</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用max-height做任意高度元素的展开收起动画</p></li><li><p>幽灵空白节点：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;  <span class="comment">/* 这个DIV本来高度应该是0，但实际不是，可自测，和font-size，line-height相关 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="第四章-盒尺寸四大家族"><a href="#第四章-盒尺寸四大家族" class="headerlink" title="第四章 盒尺寸四大家族"></a>第四章 盒尺寸四大家族</h3><p>盒尺寸中的4个盒子，content、padding、border、marginß</p><h5 id="4-1-content与替换元素"><a href="#4-1-content与替换元素" class="headerlink" title="4.1 content与替换元素"></a>4.1 content与替换元素</h5><ol><li><p>替换元素使用content可以替换原有替换属性的值，具体示例：<a href="https://demo.cssworld.cn/4/1-4.php" target="_blank" rel="noopener">https://demo.cssworld.cn/4/1-4.php</a></p></li><li><p>普通元素也可添加content属性，值若设置为url()，那元素就会被替换，表现和img标签类似，具体示例：<a href="https://demo.cssworld.cn/4/1-5.php" target="_blank" rel="noopener">https://demo.cssworld.cn/4/1-5.php</a></p></li><li><p>content替换的只是视觉替换，比如替换图片后，无法保存content属性的图片</p></li></ol><p><code>书中奇技淫巧：</code></p><ol><li><p>利用::before和::after实现两端对齐，具体示例：<a href="https://demo.cssworld.cn/4/1-7.php" target="_blank" rel="noopener">https://demo.cssworld.cn/4/1-7.php</a></p></li><li><p>配合@font-face规则实现图标字体效果，具体示例：<a href="https://demo.cssworld.cn/4/1-8.php" target="_blank" rel="noopener">https://demo.cssworld.cn/4/1-8.php</a></p></li><li><p>利用\A的换行特性，实现打点加载功能，具体示例：<a href="https://demo.cssworld.cn/4/1-9.php" target="_blank" rel="noopener">https://demo.cssworld.cn/4/1-9.php</a></p></li><li><p>content图片生成，具体示例：<a href="https://demo.cssworld.cn/4/1-10.php" target="_blank" rel="noopener">https://demo.cssworld.cn/4/1-10.php</a></p></li><li><p>content开启闭合符号生成，还可生成固定表单前缀，示例如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 生成固定闭合符号：书名号 */</span></span><br><span class="line"><span class="selector-tag">q</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">"《"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">q</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">"》"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 固定表单前缀，或其他类似功能 */</span></span><br><span class="line"><span class="selector-class">.form-item</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">"请输入："</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>content attr函数属性值内容生成</p></li><li><p>content计数器，counter-reset、counter-increment、counter()/counters()，可以像ul/ol一样制造序号，利用content的特性，结合content其他技术，可以更加灵活使用，具体示例：<a href="https://demo.cssworld.cn/4/1-11.php" target="_blank" rel="noopener">https://demo.cssworld.cn/4/1-11.php</a> ~ <a href="https://demo.cssworld.cn/4/1-19.php" target="_blank" rel="noopener">https://demo.cssworld.cn/4/1-19.php</a></p></li></ol><h5 id="4-2-温和的padding属性（温和是指很少出现意外的情况）"><a href="#4-2-温和的padding属性（温和是指很少出现意外的情况）" class="headerlink" title="4.2 温和的padding属性（温和是指很少出现意外的情况）"></a>4.2 温和的padding属性（温和是指很少出现意外的情况）</h5><ol><li>padding会影响元素的尺寸，会影响布局</li><li>padding的百分比计算始终是相对于（父元素）宽度的</li><li>各个浏览器下不同元素的默认paading值一般都不一样（即兼容问题，通常可引入一些初始化CSS文件，如normalize.css）<br><code>书中奇技淫巧：</code></li><li>实现类菜单icon（我觉得关键还是background-clip: content-box;三条线分别是上border、中content、下border，然后利用background-clip将padding的背景色隐藏掉），具体示例：<a href="https://demo.cssworld.cn/4/2-4.php" target="_blank" rel="noopener">https://demo.cssworld.cn/4/2-4.php</a></li><li>实现双圆点效果（这个原理和2差不多，就是加了border的一些特性），具体示例：<a href="https://demo.cssworld.cn/4/2-4.php" target="_blank" rel="noopener">https://demo.cssworld.cn/4/2-4.php</a></li></ol><h5 id="4-3-激进的margin属性"><a href="#4-3-激进的margin属性" class="headerlink" title="4.3 激进的margin属性"></a>4.3 激进的margin属性</h5><ol><li>padding控制元素内边距，margin控制元素外边距</li><li>元素尺寸：<ul><li>margin尺寸：无对应DOM API</li><li>border尺寸：offsetWidth/offsetHeight</li><li>padding尺寸：clientWidth/clientHeight</li><li>content尺寸：(style.width)</li></ul></li><li>某些情况下，margin会影响到元素尺寸，具体示例：<a href="https://demo.cssworld.cn/4/3-1.php" target="_blank" rel="noopener">https://demo.cssworld.cn/4/3-1.php</a></li><li>底部留白（有滚动条）不能用padding-bottom，有兼容问题（Firefox），使用margin的话留白部分没有滚动条，可多加个元素专门用作留白处理</li><li>利用margin的负值可以扩大子元素相对于父元素的限制（非常使用于：整体左右padding固定，但是中间部分突出的布局）</li><li>margin合并：块级元素的上下外边距有时会合并为单个外边距（合并的意义：如下图，考虑到h1标签的上下边距，若没有margin合并，则两个h1中间部分会是现在的2倍，这样想来，margin合并还是有点道理的）<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><img data-src="/images/1569319838971.jpg"><p><code>书中特技：</code></p><ol><li>实现等高布局：具体示例：<a href="https://demo.cssworld.cn/4/3-2.php，等高布局可百度搜索关键字：等高布局，我觉得比较靠谱的还是flex和table" target="_blank" rel="noopener">https://demo.cssworld.cn/4/3-2.php，等高布局可百度搜索关键字：等高布局，我觉得比较靠谱的还是flex和table</a></li><li>利用margin实现左右上下对齐，具体示例：<a href="https://demo.cssworld.cn/4/3-5.php" target="_blank" rel="noopener">https://demo.cssworld.cn/4/3-5.php</a></li></ol><h5 id="4-4-功勋卓越的border属性"><a href="#4-4-功勋卓越的border属性" class="headerlink" title="4.4 功勋卓越的border属性"></a>4.4 功勋卓越的border属性</h5>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> CSS </tag>
            
            <tag> 《CSS世界》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一部分 作用域和闭包</title>
      <link href="/2019/09/05/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/"/>
      <url>/2019/09/05/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>书中总结道，作用域是一套设计良好的，用来存储或访问变量的规则。对于JS来说，这套规则主要主要有以下几点：</p><ol><li>作用域嵌套（自下向上，逐级包含）</li><li>函数作用域（可以理解为形成局部作用域的规则）</li><li>块作用域（可以理解为形成局部作用域的规则）</li><li>变量名（/函数名）提升</li></ol><p>最后，书中提到由作用域规则而构造的闭包。</p><h3 id="第一章-作用域是什么"><a href="#第一章-作用域是什么" class="headerlink" title="第一章  作用域是什么"></a>第一章  作用域是什么</h3><p>这章扯到了编译原理，提到一般编译的三个步骤：词法分析、语法分析、代码生成。然后通过模拟对话的方式，简单阐述了引擎、编译器、作用域之间的关系。不过我个人觉得没啥卵用，无论是词法分析、语法分析或是代码生成，这些过程都是黑盒子，说破天在这本书里还是黑盒子。</p><p>然后介绍了作用域嵌套，感觉这是一般编程语言都会有的作用域规则。</p><h3 id="第二章-词法作用域"><a href="#第二章-词法作用域" class="headerlink" title="第二章  词法作用域"></a>第二章  词法作用域</h3><p>这里提到两种作用域的工作模型：词法作用域和动态作用域。大多数语言都使用的是词法作用域，JavaScript也是。</p><p>词法作用域就是定义在词法阶段的作用域，即由你在写代码时将变量和块作用域写在哪里决定（平时可能感觉不到，但仔细一想的话，机器肯定是没有作用域的概念，是语言本身赋予的一种能力，或规则吧）。</p><p>文中还提到了一些欺骗词法的手段，比如eval、with等。eval的功能是真的很强大，可以将字符串生成为js代码，with更像是处理对象属性的语法糖。这两个函数都不推荐使用。</p><h3 id="第三章-函数作用域和块作用域"><a href="#第三章-函数作用域和块作用域" class="headerlink" title="第三章  函数作用域和块作用域"></a>第三章  函数作用域和块作用域</h3><p>函数可以隐藏内部实现，同事函数可以形成一个局部的作用域，从而规避冲突。</p><p>这章还提到函数表达式，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);  <span class="comment">// 3</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>函数表达式可以防止函数声明本身造成的命名污染。</p><p>文中接着介绍了匿名和具名函数，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我是匿名函数..."</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐这种写法</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我的名字是Hello..."</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>书中推荐给函数表达式指定一个函数名，可以增强可读性。</p><p>接着书中详细介绍了立即执行函数表达式，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一：</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> global </span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> global </span>) </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"> &#125;(<span class="built_in">window</span>));</span><br></pre></td></tr></table></figure><p>参数还可以是函数或其他，可以根据需要更加灵活的使用。</p><p>接着书中介绍了块作用域，其实函数也是块作用域的一种。JavaScript可以形成块作用的语法主要有以下几种：</p><ol><li>函数</li><li>for循环</li><li>if语句</li><li>try/catch语句</li></ol><p>接着指出var声明的缺陷，从而（ES6）引出let、和const关键词。</p><h3 id="第四章-（变量声明）提升"><a href="#第四章-（变量声明）提升" class="headerlink" title="第四章 （变量声明）提升"></a>第四章 （变量声明）提升</h3><p>每级作用域都会进行提升操作，函数声明会被提升，但是函数表达式却不会被提升（即使是具名的函数表达式）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">// undefined</span></span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo();  <span class="comment">// TypeError  =&gt; undefined()</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line">foo();</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// var bar = ...self...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数声明和变量声明都会被提升，但是函数会首先被提升，尽管重复的var声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">foo();  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下就是，变量（包括函数声明）的声明和赋值是两个操作，声明会首先被提升到本级作用域。</p><h3 id="第五章-作用域闭包"><a href="#第五章-作用域闭包" class="headerlink" title="第五章 作用域闭包"></a>第五章 作用域闭包</h3><p>书中解释：当函数可以记住并且访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。<br>MDN（<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures</a> ）的解释：函数与对其状态即词法环境（lexical environment）的引用共同构成闭包（closure）。</p><p>关键就是函数，以及函数所持有的局部作用域的引用。闭包可以说是js早期模块化不可缺少的核心。<br>书中提到的几个和闭包相关的关键点：</p><ol><li>回调函数和闭包：只要使用了回调函数，实际上就是在使用闭包</li><li>块作用域和闭包：循环/if</li><li>模块机制</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> 《你不知道的JavaScript》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股票计算器</title>
      <link href="/2019/09/02/%E8%82%A1%E7%A5%A8%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/2019/09/02/%E8%82%A1%E7%A5%A8%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>正真加入炒股大军韭菜行列已经半年多了，其中赚了不少钱，也亏了不少钱，总的还是亏的。玩到现在也算是涨了点知识，也积累了点经验吧，至少不会每天一开盘就盯着股价不放，生怕错过了盘中大起大落，令人热血高涨的最高价，亦或令人挫骨扬灰的最低价，作为韭菜中的股神，生怕错过自己成为利弗莫尔的传奇一刻。</p><p>韭菜如何成长，就是从你不断亏钱的那一刻起。有了伤疤，人才会反思，从低谷爬向巅峰，再从巅峰跌落。</p><p>如今我更喜欢挂单，而不是盯盘。相比盯盘，挂单的方式是把炒股当做副业或者生活的小游戏，而不是你当前工作或生活的重心。挂单肯定是要分价挂单，所以要计算跌几个点加仓啊、涨几个点减仓啊啥的，所以就需要个计算股价的计算器（很遗憾，我用的东方财富APP没有这种功能）。</p><p>刚开始想做这个功能的时候，立刻就想到了Chrome扩展程序（之前写过Hello Word），感觉从功能上来讲非常适合，而且我的工作需要每天浏览器经常开着，用起来也很方便。于是便着手准备，但是chrome的限制还真是多，加载个js啥的都还得配置一下，有点麻烦，就产生一丝放弃的念头。刚好中午吃饭的时候，想到了需要手机查看这个计算器功能，手机上chrome貌似没这扩展程序功能。于是果断放弃了Chrome扩展程序的做法，决定使用Hexo建立的博客来搞。</p><h3 id="Hexo探索"><a href="#Hexo探索" class="headerlink" title="Hexo探索"></a>Hexo探索</h3><p>首先肯定是要像关于、标签、分类一样，建一个单独的page，入口也可以刚好放在导航栏里。</p><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page calculator</span><br></pre></td></tr></table></figure><p>这条命令会帮你生成source/calculator/index.md，修改index.md，添加type配置，type会在page.swig有用到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 股价计算器</span><br><span class="line">date: 2019-09-02 15:07:07</span><br><span class="line">type: calculator</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>然后配置next#_config.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  ...</span><br><span class="line">  calculator: /calculator/ || calculator(calculator)</span><br></pre></td></tr></table></figure><p>next的Icon可以参考 <a href="https://fontawesome.com" target="_blank" rel="noopener">https://fontawesome.com</a></p><p>接着需要配置中文，打开next#languages#zh-CN.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  ...</span><br><span class="line">  calculator: 股价计算器</span><br></pre></td></tr></table></figure><p>然后再next#layout下添加calculator.swig文件，修改page.swig文件，根据page.type将calculator.swig引入。</p><p>接着就可以写我的计算器了，随便写一行Hello World就有效果了。</p><p>但是还有两个问题，什么是.swig文件？还有怎么写样式啊？</p><h3 id="swig之谜"><a href="#swig之谜" class="headerlink" title=".swig之谜"></a>.swig之谜</h3><p>稍微查了一下，swig是一个ndoe.js模板，其实性质和ejs、jsp之类的差不多了。所以也不用管太多，就把它当做HTML好了，而且我这个计算器的功能基本也不会用到它的API，因为这里我只需要原生的js就行了。</p><p>直接在calculator.swig添加我需要的Input标签、button标签等，然后直接加个script标签在里面写js就行了。</p><p>但是css总不能全都写成内联模式，毕竟这模板也只是完整页面的一部分，想了想，参照标签、归档这些菜单的做法，在next#source#css#_common#components#pages下添加calculator.styl，并在pages.styl中导入即可。然后就跟平常写html没啥两样了，除了styl格式有点诡异，但和普通css也没差。</p><h3 id="股票计算器"><a href="#股票计算器" class="headerlink" title="股票计算器"></a>股票计算器</h3><p>真正写计算机的逻辑时，啪啪啪，几下就敲完了。</p><p>就在左边菜单栏，可以试试。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Hexo </tag>
            
            <tag> 股票 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时光荏苒，当以笔代替消逝的记忆</title>
      <link href="/2019/09/01/%E6%97%B6%E5%85%89%E8%8D%8F%E8%8B%92%EF%BC%8C%E5%BD%93%E4%BB%A5%E7%AC%94%E4%BB%A3%E6%9B%BF%E6%B6%88%E9%80%9D%E7%9A%84%E8%AE%B0%E5%BF%86/"/>
      <url>/2019/09/01/%E6%97%B6%E5%85%89%E8%8D%8F%E8%8B%92%EF%BC%8C%E5%BD%93%E4%BB%A5%E7%AC%94%E4%BB%A3%E6%9B%BF%E6%B6%88%E9%80%9D%E7%9A%84%E8%AE%B0%E5%BF%86/</url>
      
        <content type="html"><![CDATA[<p>偶然回头，才发现背后已然是一片空白。</p><p>也曾有过几次想要写点东西，切切实实的记录下来，而不是靠那逐渐消亡的脑细胞，但最终都以各种理由中断，比如工作太忙、现在学到的东西过于浅薄，无法掏出正真有价值的知识、甚至天真的想靠自己天才般的头脑把所有的知识都真正占为己有。无论短期记忆、长期记忆，最终都经不住时间的摧残，最后留给你的，只有习惯和空白。</p><p>上大学的时候，在博客园坚持过好长一段时间，每天都写博客(<a href="https://www.cnblogs.com/realsoul/" target="_blank" rel="noopener">我的博客</a>)，那时也是刚好刚开始接触编程的一些知识吧，兴致很高，而且也有足够的时间。从纸上谈兵到真正实战，真的是一大步，实习那会真的是一直忙着写Bug，也就不再写博客了。</p><p>这次决定开始从头积累，也有想过用博客园，或者掘金（CSDN、新浪什么的就不用考虑了，全是广告），不过就是颜值不过关，也想直接自己做个博客网站，但想想有归档、标签、搜索等，感觉功能还蛮复杂的，关键是没有设计自己做出来的东西总感觉会不满意，然后一直改，一直改，最后就疯了。还有就是之前见过Hexo NexT这个主题，真的是一见钟情，非常简洁。</p><p>这个博客从创建到配置到自己满意，大概花了半天的时间吧。Hexo真的很强大，不折腾的话，估计半个小时就搞好了吧。搁在以前，肯定是要自己搞一套主题，或者模仿Hexo搭个类似的框架，然后再半途而废，因为自己搞的主题是在是太丑了，而且自己的想法随时可能会变，改来改去就烦了。现在这种什么都想自己搞一套的想法转瞬即逝，以前是要自己代码敲得爽，现在是要程序用的爽。</p><p>发现自己真的变了很多，以前写这种Hello World的时候，一定要先定个小目标：比如每天写个10篇博客。现在觉得真的没必要强迫自己每天去写博客了，我只想把自己不想忘记的东西记录在这里。</p><p>9月，有个好的开始吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
